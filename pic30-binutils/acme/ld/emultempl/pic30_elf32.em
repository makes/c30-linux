# This shell script emits a C file. -*- C -*-
# It does some substitutions.
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* emulate the original gld for the given ${EMULATION_NAME}
   Copyright (C) 1991, 93, 94, 95, 96, 1999 Free Software Foundation, Inc.
   Written by Steve Chamberlain steve@cygnus.com

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "getopt.h"
#include "genlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"

#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"

#include "ldemul.h"

#include "libbfd.h"

#include "elf-bfd.h"
#include <elf/pic30.h>
#include "../bfd/pic30-utils.h"
#include "../bfd/pic30-options.h"

#include "ctype.h"

/* defined in bfd/pic30-attributes.c */
char * pic30_section_size_string
  PARAMS ((asection *));
char * pic30_section_attr_string
  PARAMS ((asection *));

extern const char *outer_archive_name(bfd *);
extern bfd *handle_bfd;
extern bfd *pic30_output_bfd;
extern unsigned char *handle_data;
extern struct handle_hash_table *handles;
extern struct pic30_section *data_sections;

extern char *pic30_startup0_file;
extern char *pic30_startup1_file;

extern bfd_boolean need_dma_memory;
extern bfd_vma data_base;
extern bfd_boolean data_base_defined;
extern bfd_vma dma_base;
extern bfd_boolean dma_base_defined;
extern bfd_vma dma_end;
extern bfd_boolean dma_end_defined;

extern bfd *init_bfd;
extern unsigned char *init_data;
extern asection *init_template;

extern bfd *isr_bfd;
extern unsigned char *isr_data;

extern unsigned int pic30_boot_flash_size;
extern unsigned int pic30_boot_ram_size;
extern unsigned int pic30_secure_flash_size;
extern unsigned int pic30_secure_ram_size;

struct traverse_hash_info
{
  bfd *abfd;
  asection *sec;
};

struct lma_adjust_info
{
  bfd_vma base;
  bfd_vma adjust;
  bfd_vma limit;
};

/* defined in ldlang.c */
#if 1
extern lang_statement_list_type statement_list;
#endif

extern const bfd_arch_info_type * pic30_get_machine(const char * const);
extern int pic30_is_dsp_machine(const bfd_arch_info_type *);
extern int pic30_is_eedata_machine(const bfd_arch_info_type *);
extern int pic30_is_dma_machine(const bfd_arch_info_type *);
extern int pic30_is_eds_machine(const bfd_arch_info_type *);
extern void pic30_load_codeguard_settings(const bfd_arch_info_type *, int);
extern void pic30_clear_codeguard_settings(void);
extern void * pic30_lookup_valid_codeguard_setting(unsigned int);
extern void * pic30_lookup_codeguard_setting(unsigned int, unsigned int);
extern char * pic30_codeguard_setting_name(void *);
extern unsigned int pic30_codeguard_setting_flags(void *s);
extern bfd_vma pic30_codeguard_setting_address(void *s);
extern int pic30_add_selected_codeguard_option(void *);
extern void pic30_dump_selected_codeguard_options(FILE *);
extern char * pic30_unique_selected_configword_names(void);
extern int pic30_decode_CG_settings(char *, unsigned short, int);
extern unsigned short pic30_encode_CG_settings(char *);
extern void pic30_set_extended_attributes(asection *,
                                          unsigned int, unsigned char );

extern const bfd_arch_info_type * global_PROCESSOR;

extern unsigned int pic30_attribute_map
  PARAMS ((asection *));

extern int pic30_set_implied_attributes
  PARAMS ((asection *, unsigned char));

void pic30_set_output_section_flags
  PARAMS ((lang_output_section_statement_type *));

static struct bfd_hash_entry *handle_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

static void handle_hash_traverse
  PARAMS ((struct handle_hash_table *,
           bfd_boolean (*func) PARAMS ((struct bfd_hash_entry *, PTR)),
           PTR));

static struct handle_hash_table * handle_hash_init
  PARAMS ((void));

static void pic30_build_section_list
  PARAMS ((bfd *, asection *, PTR));

static void pic30_build_psv_section_list
  PARAMS ((bfd *, asection *, PTR));

static void pic30_build_code_section_list
  PARAMS ((bfd *, asection *, PTR));

static void allocate_memory
  PARAMS ((void));

static int allocate_program_memory
  PARAMS ((void));

static int allocate_auxflash_memory
  PARAMS ((void));

static int allocate_data_memory
  PARAMS ((void));

static void allocate_default_stack
  PARAMS ((void));

static int allocate_eedata_memory
  PARAMS ((void));

static int allocate_user_memory
  PARAMS ((void));

static int locate_sections
  PARAMS ((unsigned int, unsigned int, struct memory_region_struct *));

static bfd_vma next_aligned_address
  PARAMS (( bfd_vma, unsigned int));

static bfd_vma prev_aligned_address
  PARAMS (( bfd_vma, unsigned int));

static void build_alloc_section_list
  PARAMS ((unsigned int, unsigned int));

static void build_free_block_list
  PARAMS ((struct memory_region_struct *, unsigned int, unsigned int));

static arelent ** bfd_pic30_load_relocs
  PARAMS ((bfd *, asection *, asymbol **));

static void bfd_pic30_add_handle_sym
  PARAMS ((const char *, flagword));

static asection * bfd_pic30_create_section
  PARAMS ((bfd *, const char *, int, int));

static void bfd_pic30_create_symbol
  PARAMS ((bfd *, char *, asection *, int, int));

static void bfd_pic30_create_reloc
  PARAMS ((bfd *, int, int, int));

static void bfd_pic30_save_relocs
  PARAMS ((asection *));

static bfd_boolean bfd_pic30_dump_handle_entry
  PARAMS ((struct bfd_hash_entry *, PTR));

static bfd_boolean bfd_pic30_create_jump_table_entry
  PARAMS ((struct bfd_hash_entry *, PTR));

static bfd * bfd_pic30_create_jump_table_bfd
  PARAMS ((bfd *));

static bfd * bfd_pic30_create_data_init_bfd
  PARAMS ((bfd *));

static bfd * bfd_pic30_create_default_isr_bfd
  PARAMS ((bfd *));

static void bfd_pic30_add_bfd_to_link
  PARAMS ((bfd *, const char *));

static void bfd_pic30_scan_data_section
  PARAMS ((asection *, PTR));

static void bfd_pic30_skip_data_section
  PARAMS ((asection *, PTR));

static void bfd_pic30_print_section_header
  PARAMS ((void));

static void bfd_pic30_report_sections
  PARAMS ((bfd *, asection *, PTR));

static void pic30_strip_sections
  PARAMS ((bfd *));

struct bfd_link_hash_entry *bfd_pic30_is_defined_global_symbol
  PARAMS ((const char *const));

static void bfd_pic30_redefine_global_symbol
  PARAMS ((const char *const , asection *, bfd_vma));

static bfd_boolean bfd_pic30_undefine_one_symbol_bfd
  PARAMS ((struct bfd_link_hash_entry *, PTR));

static void bfd_pic30_undefine_symbols_bfd
  PARAMS ((bfd *));

static void bfd_pic30_remove_archive_module
  PARAMS ((const char *const));

static void bfd_pic30_print_region_info
  PARAMS ((const char *const));

static void bfd_pic30_before_parse
  PARAMS ((void));

static void bfd_pic30_after_parse
  PARAMS ((void));

static bfd_boolean bfd_pic30_process_bfd_after_open
  PARAMS ((bfd *, struct bfd_link_info *));

static void  bfd_pic30_update_psv_section_address
  PARAMS ((struct pic30_section *));

static void bfd_pic30_adjust_psv_sections
  PARAMS ((void));

static void bfd_pic30_tabulate_gaps_worker
  PARAMS ((lang_statement_union_type *));

static void bfd_pic30_tabulate_gaps
  PARAMS ((void));

static void record_last_program_address
  PARAMS ((bfd *, asection *, PTR));

static void bfd_pic30_finish
  PARAMS ((void));

static void bfd_pic30_report_program_sections
  PARAMS ((asection *, FILE *));

static void bfd_pic30_report_eedata_sections
  PARAMS ((asection *, FILE *));

static void bfd_pic30_report_data_sections
  PARAMS ((asection *, FILE *));

static void bfd_pic30_report_memory_sections
  PARAMS ((const char *, asection *, FILE *));

static void report_percent_used
  PARAMS ((bfd_vma, bfd_vma, FILE *));

static void bfd_pic30_report_memory_usage
  PARAMS ((FILE *));

static bfd_boolean pic30_build_data_symbol_list
  PARAMS ((struct bfd_link_hash_entry *, PTR));

static bfd_boolean pic30_build_eedata_symbol_list
  PARAMS ((struct bfd_link_hash_entry *, PTR));

static bfd_boolean pic30_build_program_symbol_list
  PARAMS ((struct bfd_link_hash_entry *, PTR));

static int compare_symbol_value
  PARAMS ((const void *, const void *));

static int compare_symbol_name
  PARAMS ((const void *, const void *));

static void pic30_report_external_symbols
  PARAMS ((FILE *));

static lang_memory_region_type *region_lookup
  PARAMS ((char *));

static bfd_boolean elf_link_check_archive_element
  PARAMS ((char *, bfd *, struct bfd_link_info *));

static void update_object_compatibility
  PARAMS ((const char *, bfd *, unsigned int *, unsigned int *));

static bfd_boolean bfd_has_signature
  PARAMS ((bfd *, unsigned int *, unsigned int *, unsigned int *));

static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
static void gld${EMULATION_NAME}_after_parse PARAMS ((void));
static void gld${EMULATION_NAME}_set_output_arch PARAMS ((void));
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
static void gld${EMULATION_NAME}_after_allocation PARAMS ((void));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_finish PARAMS ((void));
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
static int  gld${EMULATION_NAME}_place_orphan
  PARAMS((lang_input_statement_type *, asection *)); 

/*****************************************************************************/

/*
** Emulation Data Structures
*/


/* ID string to use when tabulating GAPS */
const char *GAP_ID = "%GAPS";

/* Initial Size of the Handle Hash Table */
#define HANDLE_INIT 20

/* Symbol Tables */
static asymbol **syms;

static asymbol **symtab;
static int symptr;

/* Reloc Tables */
static arelent **rels;
static long relcount = 0;

static arelent *reltab =0;
static int relcnt = 0, relsize = 0;

/* The Number of Handle Relocations */
static unsigned long handle_relocs;

/* Dynamic Memory Info */
static unsigned int stack_base, stack_limit;
static unsigned int heap_base, heap_limit;
static bfd_boolean has_const_section = FALSE;
static bfd_boolean has_psv_section = FALSE;
static bfd_boolean has_psvpag_reference = FALSE;
static bfd_boolean user_defined_stack = FALSE;
static bfd_boolean heap_section_defined = FALSE;
static bfd_boolean stack_section_defined = FALSE;
static bfd *heap_bfd, *stack_bfd;
#define PSV_BASE 0x8000
#define EEDATA_BASE 0x7ff000

/* X/Y boundary info */
static bfd_vma ydata_base = 0;
static bfd_boolean ydata_base_defined = FALSE;

/* Memory Reporting Info */
static bfd_size_type actual_prog_memory_used = 0;
static bfd_size_type actual_eedata_memory_used = 0;
static bfd_size_type data_memory_used = 0;
static bfd_size_type external_memory_used = 0;

/* User Initialization Functions */
static bfd_boolean has_user_init_functions = FALSE;
static bfd *user_init_bfd;
static unsigned char *user_init_data;
static bfd_vma user_init_offset = 0;

/* User-defined memory regions */
static bfd_boolean has_user_defined_memory = FALSE;
const char *memory_region_prefix = "__memory_";
static struct pic30_section *memory_region_list;
static struct pic30_section *user_memory_sections;

/* Memory Models */
static bfd_boolean has_unified_data_model = FALSE;
static bfd_boolean has_full_eds_memory_model = FALSE;

/* Section Lists */
static struct pic30_section *pic30_section_list;
static struct pic30_section *psv_sections, *code_sections;

struct pic30_section *unassigned_sections;
static struct pic30_section *alloc_section_list;

/* Free Memory List */
struct pic30_memory
{
  struct pic30_memory *next;
  bfd_vma addr;
  bfd_vma size;
  bfd_vma offset;
};
static struct pic30_memory *free_blocks, *data_memory_free_blocks;

/* Symbol Lists */
struct pic30_symbol
{
  char    *name;
  bfd_vma value;
};
static struct pic30_symbol *pic30_symbol_list;
int pic30_symbol_count;
int pic30_max_symbols;
#define PIC30_INIT_SYM_COUNT 20
#define PIC30_GROW_SYM_COUNT 10

/* CodeGuard Access Structures */
static char boot_access[NUM_BOOT_ACCESS_SLOTS] = { 0 };
static char secure_access[NUM_SECURE_ACCESS_SLOTS] = { 0 };
static bfd_boolean has_boot_access = FALSE;
static bfd_boolean has_secure_access = FALSE;

static bfd_boolean boot_unused_entry_defined = FALSE;
static bfd_boolean boot_isr_entry_defined = FALSE;
static bfd_boolean secure_unused_entry_defined = FALSE;
static bfd_boolean secure_isr_entry_defined = FALSE;

extern bfd_vma base_address[SEGMENTS][MEMORIES];
extern bfd_vma  end_address[SEGMENTS][MEMORIES];
static unsigned int alloc_region_index;

static char * valid_cg_section_names[] = {
  "__FBS.sec",
  "__FSS.sec",
  "__FGS.sec",
  0, };

/* The Upper Limit of Region "Program" */
static bfd_vma upper_limit_program = 0;

/* The Last Location Used in Program Memory */
static bfd_vma last_program_address = 0;
#define PROGRAM_WORD_SIZE 2

/*
** smart_io Data Structure
**
** The following data structure is used to identify
** I/O function pairs that have redundant functionality.
** The "full_set" function is a standard I/O function
** such as printf(). The "reduced_set" function has the
** same type and parameter list but supports a reduced
** feature set, such as the integer-only _iprintf().
**
** If both members of a function pair are defined,
** the reduced_set function is considered redundant.
** The --smart-io option causes the linker to merge
** the two functions in order to conserve memory.
**
** Function merging is performed by the _after_open()
** emulation entry point, after all the input BFDs
** have been opened, but before memory is allocated.
**
** Function merging consists of several steps:
**
** 1. Lookup both function names in the Global Linker
**    Hash Table and load pointers to the corresponding
**    hash table entries.
**
** 2. Copy the (value) and (section) fields from the
**    full_set hash table entry to the reduced_set hash
**    table entry. This causes the reduced_set function
**    name to be a synonym for the full_set function name.
**
**    This operation is valid because:
**
**    (section) is a pointer into a BFD data structure.
**    When a BFD is opened, it remains locked in memory
**    until it is closed at the completion of the link.
**    Pointers into a BFD data structure are guaranteed
**    not to move.
**
**    (value) is an offset into an input section. Offsets
**    within an input section are determined by the
**    assembler and do not change during the link.
**
** 3. Loop through each input statement in the linker script
**    and find the BFD associated with the reduced_set
**    function, based on its module_name.
**
** 4. Traverse the Global Linker Hash Table and change the
**    type of any symbols that are defined and owned by
**    the reduced_set BFD to "undefined".
**
** 5. For each section attached to the reduced_set BFD,
**    set the SEC_NEVER_LOAD section flag and set the
**    section size to zero. This causes the reduced_set
**    function to be omitted from the final link.
*/

#if (defined(C30_SMARTIO_RULES) && (C30_SMARTIO_RULES > 1))
struct reduced_set_list {
  char *reduced_set;
  char *module_name;
  struct reduced_set_list *next;
};

struct function_pair_type
{
  char *full_set;
  char *prefix;
  struct reduced_set_list *rsl;
};

  /* With RULES == 2 we put flags after the function name, almost like
     C++ encoding.  We need to select the function with the minimum set of
     extra flags at the end */
struct function_pair_type function_pairs[] =
  {
    /* iprintf() */
    { "_printf",    "__printf",   0  },
    { "__Printf",   "___Printf",  0  },
    { "__Putfld",   "___Putfld",  0  },

    { "__dprintf",  "__dprintf",   0  },
    { "___dPrintf", "___dPrintf",  0  },
    { "___dPutfld", "___dPutfld",  0  },

    /* ifprintf() */
    { "_fprintf",   "__fprintf",  0  },
    { "__dfprintf", "__dfprintf",  0  },

    /* isprintf() */
    { "_sprintf",   "__sprintf",  0  },
    { "__dsprintf", "__dsprintf",  0  },

    /* ivprintf() */
    { "_vprintf",   "__vprintf",  0  },
    { "__dvprintf", "__dvprintf",  0  },

    /* ivfprintf() */
    { "_vfprintf",  "__vfprintf",  0 },
    { "__dvfprintf","__dvfprintf",  0 },

    /* ivsprintf() */
    { "_vsprintf",  "__vsprintf",  0 },
    { "__dvsprintf","__dvsprintf",  0 },

    /* isnprintf() */
    { "_snprintf",  "__snprintf",  0 },
    { "__dsnprintf","__dsnprintf",  0 },

    /* ivsnprintf() */
    { "_vsnprintf", "__vsnprintf", 0 },
    { "__dvsnprintf","__dvsnprintf",0 },

    /* iscanf() */
    { "_scanf",     "__scanf",     0 },
    { "__Scanf",    "___Sscanf",   0 },
    { "__Getfld",   "___Getfld",   0 },

    { "__dscanf",   "__dscanf",     0 },
    { "___dScanf",  "___dSscanf",   0 },
    { "___dGetfld", "___dGetfld",   0 },

    /* ifscanf() */
    { "_fscanf",    "__fscanf",    0 },
    { "__dfscanf",  "__dfscanf",    0 },

    /* isscanf() */
    { "_sscanf",    "__sscanf",    0 },
    { "__dsscanf",  "__dsscanf",    0 },

    /* ldtob */
    { "___Ldtob",   "___Ldtob",    0 },
    { "___Genld",   "___Genld",    0 },

    /* null terminator */
    { 0, 0, 0 },
  };
#else
struct function_pair_type
{
  char *full_set;
  char *reduced_set;
  char *module_name;
};

const struct function_pair_type function_pairs[] =
  {
    /* iprintf() */
    { "_printf",    "__iprintf",   "printf.eio"    },
    { "__Printf",   "___iPrintf",  "xprintf.eio"   },
    { "__Putfld",   "___iPutfld",  "xputfld.eio"   },

    { "__dprintf",  "__iprintf",   "printf.eio"    },
    { "___dPrintf", "___iPrintf",  "xprintf.eio"   },
    { "___dPutfld", "___iPutfld",  "xputfld.eio"   },

    /* ifprintf() */
    { "_fprintf",   "__ifprintf",  "fprintf.eio"   },
    { "__dfprintf", "__ifprintf",  "fprintf.eio"   },

    /* isprintf() */
    { "_sprintf",   "__isprintf",  "sprintf.eio"   },
    { "__dsprintf", "__isprintf",  "sprintf.eio"   },

    /* ivprintf() */
    { "_vprintf",   "__ivprintf",  "vprintf.eio"   },
    { "__dvprintf", "__ivprintf",  "vprintf.eio"   },

    /* ivfprintf() */
    { "_vfprintf",  "__ivfprintf",  "vfprintf.eio" },
    { "__dvfprintf","__ivfprintf",  "vfprintf.eio" },

    /* ivsprintf() */
    { "_vsprintf",  "__ivsprintf",  "vsprintf.eio" },
    { "__dvsprintf","__ivsprintf",  "vsprintf.eio" },

    /* isnprintf() */
    { "_snprintf",  "__isnprintf",  "snprintf.eio" },
    { "__dsnprintf","__isnprintf",  "snprintf.eio" },

    /* ivsnprintf() */
    { "_vsnprintf", "__ivsnprintf", "vsnprint.eio" },
    { "__dvsnprintf","__ivsnprintf","vsnprint.eio" },

    /* iscanf() */
    { "_scanf",     "__iscanf",     "scanf.eio"    },
    { "__Scanf",    "___iSscanf",   "xscanf.eio"   },
    { "__Getfld",   "___iGetfld",   "xgetfld.eio"  },

    { "__dscanf",   "__iscanf",     "scanf.eio"    },
    { "___dScanf",  "___iSscanf",   "xscanf.eio"   },
    { "___dGetfld", "___iGetfld",   "xgetfld.eio"  },

    /* ifscanf() */
    { "_fscanf",    "__ifscanf",    "fscanf.eio"   },
    { "__dfscanf",  "__ifscanf",    "fscanf.eio"   },

    /* isscanf() */
    { "_sscanf",    "__isscanf",    "sscanf.eio"   },
    { "__dsscanf",  "__isscanf",    "sscanf.eio"   },

    /* null terminator */
    { 0, 0, 0 },
  };
#endif

/*****************************************************************************/

/*
** Prototypes that use local structure definitions
*/

static void pic30_init_section_list
  PARAMS ((struct pic30_section **));

static void pic30_append_section_to_list
  PARAMS ((struct pic30_section *, lang_input_statement_type *, asection *));

static bfd_boolean pic30_name_in_section_list
  PARAMS ((struct pic30_section *, const char *));

static void pic30_remove_from_section_list
  PARAMS ((struct pic30_section *, struct pic30_section *));

static void pic30_remove_group_from_section_list
  PARAMS ((struct pic30_section *, const char *));

static void pic30_print_section_list
  PARAMS ((struct pic30_section *, const char *));

static int pic30_section_list_length
  PARAMS ((struct pic30_section *));

static void pic30_free_section_list
  PARAMS ((struct pic30_section **));

static void pic30_append_section_lists
  PARAMS ((struct pic30_section *, struct pic30_section *));

static void pic30_init_symbol_list
  PARAMS ((struct pic30_symbol **));

static void pic30_add_to_symbol_list
  PARAMS ((struct pic30_symbol **, const char *, bfd_vma));

static void pic30_print_symbol_list
  PARAMS ((struct pic30_symbol *, FILE *, int));

static void pic30_init_memory_list
  PARAMS ((struct pic30_memory **));

static void pic30_add_to_memory_list
  PARAMS ((struct pic30_memory *, bfd_vma, bfd_vma));

static struct pic30_memory * pic30_static_assign_memory
  PARAMS ((struct pic30_memory *, bfd_vma, bfd_vma));

static struct pic30_memory * pic30_best_fit_memory
  PARAMS ((struct pic30_memory *, bfd_vma, unsigned int, bfd_boolean));

static void pic30_remove_from_memory_list
  PARAMS ((struct pic30_memory *, struct pic30_memory *)); 

static void pic30_free_memory_list
  PARAMS ((struct pic30_memory **));

static void confirm_dma_range_defined
  PARAMS ((void));

static void print_output_section_statement
  PARAMS ((lang_output_section_statement_type *));

static struct pic30_memory * select_free_block
  PARAMS ((struct pic30_section *, unsigned int));

static void remove_free_block
  PARAMS ((struct pic30_memory *));

static void insert_alloc_section
  PARAMS ((struct pic30_section *, struct pic30_section *));

static void update_section_info
  PARAMS ((bfd_vma,
           struct pic30_section *, struct memory_region_struct *));

static void update_group_section_info
  PARAMS ((bfd_vma,
           struct pic30_section *, struct memory_region_struct *));

static void create_remainder_blocks
  PARAMS ((struct pic30_memory *, unsigned int));

/*
** BFD Utility Routines
*/

/* print reloc - internal form (arelent) */
#define DUMP_RELOC(n,r)                              \
{                                                    \
   fprintf (stderr,"  %s sym %d, addr %d, addend %d\n", \
	   n, (*(r->sym_ptr_ptr))->name,             \
	   r->address, r->addend);                   \
}

/* print reloc - canonical form (arelent) */
#define DUMP_CANON_RELOC(n,r)                              \
{                                                    \
   fprintf (stdout,"  %s sym %s, addr %ld, addend %ld\n", \
	   n, (*(r->sym_ptr_ptr))->name,             \
	   r->address, r->addend);                   \
}

/* print reloc - external form */
#define DUMP_RELOC2(n,r)                     \
{                                            \
   fprintf (stderr,"  %s sym %d, r_vaddr 0x%lx\n", \
	   n, (int) r->r_symndx, (long) r->r_vaddr);      \
}

/*****************************************************************************
**
** Functions to access boundaries of standard memory regions
*/

static bfd_vma
program_base_address(void) {
  lang_memory_region_type *region =
    region_lookup("program");
  return region->origin;
}

static bfd_vma
program_end_address(void) {
  lang_memory_region_type *region =
    region_lookup("program");
  return region->origin + region->length - 2;
}

static bfd_vma
data_base_address(void) {
  lang_memory_region_type *region =
    region_lookup("data");
  return region->origin;
}

static bfd_vma
data_end_address(void) {
  lang_memory_region_type *region =
    region_lookup("data");
  return region->origin + region->length - 1;
}

static bfd_vma
eedata_base_address(void) {
  lang_memory_region_type *region =
    region_lookup("eedata");
  return region->origin;
}

static bfd_vma
eedata_end_address(void) {
  lang_memory_region_type *region =
    region_lookup("eedata");
  return region->origin + region->length - 2;
}


/*****************************************************************************
**
** Linker Statement List Utilities
**
** These functions are used to interrogate the
** statement list that is created after parsing
** a linker script.
*/

static const char    *early_assign_name;
static int     early_assign_found;
static bfd_vma *early_assign_value;

static void
early_assignment_worker(lang_statement_union_type *statement)
{
  if ((statement->header.type == lang_assignment_statement_enum) &&
      (strcmp(statement->assignment_statement.exp->assign.dst,
              early_assign_name) == 0))
    {
      union etree_union *src = statement->assignment_statement.exp->assign.src;

      if (src->type.node_class == etree_value) {
        early_assign_found = 1;
        *early_assign_value = src->value.value;
      }
    }
}

/*
** Look for a symbol that has been assigned early.
**
** This means a value has been assigned that is
** not dependant on memory allocation, and is
** therefore available early in the link process.
*/
static int
early_assignment(bfd_vma *val, const char *name)
{
  if (pic30_debug)
    printf("\nLooking for early assignment %s ", name);

  early_assign_found = 0;
  early_assign_name = name;
  early_assign_value = val;
  lang_for_each_statement (early_assignment_worker);

  if (pic30_debug) {
    if (early_assign_found)
      printf("= %lx\n", *early_assign_value);
    else
      printf("(not found)\n");
  }

  return early_assign_found;
}


/*****************************************************************************
**
** Handle Hash Table Routines
**
** We use a hash table to keep track of
** unique symbols referenced in handle relocations.
**
** Each symbol has an entry in the jump table
** which is resolved at reloc time.
**
** The total size of the jump table is determined
** by the number of unique symbols.
**
** This hash table is derived from the basic
** table provided in /bfd/hash.c
*/


/*
** Create a new hash table entry
*/
static struct bfd_hash_entry *
handle_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct handle_hash_entry *ret = (struct handle_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct handle_hash_entry *) NULL)
    ret = ((struct handle_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct handle_hash_entry)));
  if (ret == (struct handle_hash_entry *) NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct handle_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
      ret->index    = -1;
      ret->sym      = 0;
    }

  return (struct bfd_hash_entry *) ret;
}

#if 0
/*
** Look up a hash table entry
*/
#define handle_hash_lookup(t, string, create, copy) \
  ((struct handle_hash_entry *) \
   bfd_hash_lookup (&(t)->table, (string), (create), (copy)))
#endif


/*
** Traverse the hash table
**
** Calls a function for each entry
*/
static void
handle_hash_traverse (table, func, info)
     struct handle_hash_table *table;
     bfd_boolean (*func) PARAMS ((struct bfd_hash_entry *, PTR));
     PTR info;
{
  bfd_hash_traverse (&table->table,
		     ((bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR)))
		      func),
		     info);
}


/*
** Create a new hash table
*/
static struct handle_hash_table *
handle_hash_init ()
{
  struct handle_hash_table *table;

  table = ((struct handle_hash_table *)
	   bfd_alloc (output_bfd, sizeof (struct handle_hash_table)));
  if (table == NULL)
    return NULL;

  if (! bfd_hash_table_init_n (&table->table, handle_hash_newfunc, HANDLE_INIT))
    {
      free (table);
      return NULL;
    }

  table->num = 0;

  return table;
}

#if 0
/*
** Free a hash table
*/
static void
handle_hash_free (table)
     struct handle_hash_table *table;
{
  bfd_hash_table_free (&table->table);
  free (table);
}
#endif

/*****************************************************************************
**
** Section List Routines
**
** Maintain a list of sections in order
** of ascending load address.
**
** Used for creating memory usage reports.
**
*/

/*
** Create a new list
**
** - first item is null
*/
static void
pic30_init_section_list(lst)
     struct pic30_section **lst;
{
  *lst = ((struct pic30_section *)
         xmalloc(sizeof(struct pic30_section)));
  (*lst)->next = 0;
  (*lst)->sec = 0;
  (*lst)->attributes = 0;
  (*lst)->file = 0;
}


/*
** Append a section to a list
*/
static void
pic30_append_section_to_list (struct pic30_section *lst,
                              lang_input_statement_type *file,
                              asection *sec)
{
  struct pic30_section *s, *tail, *new;

  if (!(lst))
    return;
  /* create a new element */
  new = ((struct pic30_section *) 
         xmalloc(sizeof(struct pic30_section)));
  new->next  = 0;
  new->sec  = sec;
  new->attributes = pic30_attribute_map(sec);
  new->file = (PTR) file;

  /* find the tail */
  for (s = lst; s != NULL; s = s->next)
    tail = s;

  tail->next = new;  /* add it */
}


/*
** Add a section to the list
**
** - in order of increasing load address
** - this function is called via bfd_map_over_sections()
*/
static void
pic30_build_section_list (abfd, sect, fp)
     bfd *abfd ATTRIBUTE_UNUSED ;
     asection *sect;
     PTR fp ATTRIBUTE_UNUSED ;
{
  struct pic30_section *new, *s, *prev;
  int done = 0;

  /* create a new element */
  new = ((struct pic30_section *) 
         xmalloc(sizeof(struct pic30_section)));
  new->sec  = sect;
  new->attributes = pic30_attribute_map(sect);
  new->file = 0;

  /* insert it at the right spot */
  prev = pic30_section_list;
  for (s = prev; s != NULL; s = s->next)
    {
      if (s->sec && (new->sec->lma < s->sec->lma))
        {
          prev->next = new;
          new->next = s;
          done++;
          break;
        }
      prev = s;
    }

  if (!done)
    {
      prev->next = new;
      new->next = NULL;
    }
} /* static void pic30_build_section_list (...) */


/*
** Search a section list by name
*/
static bfd_boolean
pic30_name_in_section_list (lst, name)
     struct pic30_section *lst;
     const char *name; 
{
  struct pic30_section *s, *next;
  for (s = lst; s != NULL; s = next) {
    next = s->next;
    if (s->sec && strcmp(s->sec->name, name) == 0)
      return TRUE;
  }
  return FALSE;
}

/*
** Remove an element from a section list
*/
static void
pic30_remove_from_section_list (lst, sec)
     struct pic30_section *lst;
     struct pic30_section *sec; 
{
  struct pic30_section *s, *prev, *next;
  int done = 0;

  prev = lst;
  for (s = prev; s != NULL; s = next)
    {
      next = s->next;
      if (s == sec)
        {
          prev->next = next;
          free(s);
          done = 1;
          break;
        }
      prev = s;
    }

  /*
   * If we didn't find it, search for element->section.
   * This enables us to remove an element that was
   * identified from another list.
   *
   * Example: Remove a member of "unassigned sections"
   * that was identified from an allocation list.
   */
  if (!done)
    {
      prev = lst;
      for (s = prev; s != NULL; s = next)
        {
          next = s->next;
          if (s->sec == sec->sec)
            {
              prev->next = next;
              free(s);
              done = 1;
              break;
            }
          prev = s;
        }
    }

  if (pic30_debug && (done == 0))
    printf("    !Could not remove section \"%s\" from list at %lx\n",
           sec->sec->name, (long unsigned int) &lst);

} /* pic30_remove_from_section_list (..) */

/*
** Remove a group from a section list
**
** Sections in a group are related by name.
** We can't delete them, so we clear the
** attributes field so they won't match
** any more allocation stages.
*/
static void
pic30_remove_group_from_section_list (lst, name)
     struct pic30_section *lst;
     const char *name; 
{
  struct pic30_section *s, *prev, *next;

  prev = lst;
  for (s = prev; s != NULL; s = next)
    {
      next = s->next;
      if (s->sec && (strcmp(s->sec->name, name) == 0))
        {
          s->attributes = 0;
        }
      prev = s;
    }
} /* pic30_remove_group_from_section_list() */

/*
** Print a section list
*/
static void
pic30_print_section_list (lst, name)
     struct pic30_section *lst;
      const char *name;
{
  unsigned int opb = bfd_octets_per_byte (output_bfd);
  struct pic30_section *s, *prev, *next;

  printf("\nContents of %s section list at %lx:\n", name, (bfd_vma) lst);
  prev = lst;
  for (s = prev; s != NULL; s = next)
    {
      next = s->next;
      printf("  name = %s, addr = %lx, len = %lx, attr = %x\n",
             s->sec ? s->sec->name : "(none)",
             s->sec ? s->sec->lma : 0,
             s->sec ? s->sec->_raw_size / opb : 0,
             s->attributes);
      prev = s;
    }
  printf("\n");

} /* pic30_print_section_list (..) */


/*
** Length of a section list
*/
static int
pic30_section_list_length (lst)
     struct pic30_section *lst;
{
  struct pic30_section *s;
  int count = -1; /* first element is null */

  for (s = lst; s != NULL; s = s->next)
      count++;

  return count;

} /* pic30_section_list_length (..) */


/*
** Free a section list
*/
static void
pic30_free_section_list(lst)
     struct pic30_section **lst;
{
  struct pic30_section *s, *next;

  if (!(*lst))
    return;

  for (s = *lst; s != NULL; s = next)
    {
      next = s->next;
      free(s);
    }

  *lst = NULL;
} /* static void pic30_free_section_list (...) */


/*
** Append two section lists
*/
static void
pic30_append_section_lists(lst1, lst2)
     struct pic30_section *lst1, *lst2;
{
  struct pic30_section *s, *tail;

  if (!(lst1))
    return;

  for (s = lst1; s != NULL; s = s->next)
    tail = s;

  tail->next = lst2;

} /* static void pic30_free_section_list (...) */


/*****************************************************************************
**
** Symbol List Routines
**
** Used to generate symbol tables in the link map.
**
** Note: symbol lists are *not* linked, and are
** intended for sorting.
**
** FIXME: Despite appearances to the contrary, there
** can be only one symbol list active at a time.
**
*/

/*
** Create a new symbol list
*/
static void
pic30_init_symbol_list(lst)
     struct pic30_symbol **lst;
{
  *lst = ((struct pic30_symbol *)
         xmalloc(sizeof(struct pic30_symbol) * PIC30_INIT_SYM_COUNT));
  pic30_max_symbols = PIC30_INIT_SYM_COUNT;
  pic30_symbol_count = 0;
}

/*
** Append to a symbol list
*/
static void
pic30_add_to_symbol_list(lst, name, value)
     struct pic30_symbol **lst;
     const char *name;
     bfd_vma value;
{
  if (pic30_symbol_count >= pic30_max_symbols) {
    pic30_max_symbols += PIC30_GROW_SYM_COUNT;
    *lst = ((struct pic30_symbol *)
            xrealloc( *lst, sizeof(struct pic30_symbol) * pic30_max_symbols));
  }

  (*lst)[pic30_symbol_count].name = (char *) name;
  (*lst)[pic30_symbol_count].value = value;
  ++pic30_symbol_count;
}

/*
** Print a symbol list
**
** format = 1 for data memory (16 bit address)
**          2 for program memory (24 bit address)
*/
static void
pic30_print_symbol_list(lst, fp, format)
     struct pic30_symbol *lst;
     FILE *fp;
     int format;
{
  int i;
  char *s = " ";

  for (i=0; i<pic30_symbol_count; i++)
    if (format == 1)
      fprintf( fp, "%20s0x%04lx%18s%s\n", s, lst[i].value, s, lst[i].name );
    else
      fprintf( fp, "%18s0x%06lx%18s%s\n", s, lst[i].value, s, lst[i].name );
}


/*****************************************************************************
**
** Memory Allocation Routines
**
** Used by bfd_pic30_adjust_psv_sections()
** to re-allocate sections above a certain
** threshold.
**
*/


/*
** Build a list of PSV sections
**  in order of decreasing size
**
** - this function is called via bfd_map_over_sections()
*/
static void
pic30_build_psv_section_list (abfd, sect, p)
     bfd *abfd ATTRIBUTE_UNUSED ;
     asection *sect;
     PTR p;
{
  struct lma_adjust_info *info = (struct lma_adjust_info *) p;
  struct pic30_section *new, *s, *prev;
  int done = 0;

  /*
  ** exit if not PSV, or below threshold, or above limit
  */
  int isPSV = PIC30_IS_PSV_ATTR(sect);
  if (!isPSV || (sect->lma < info->base) || (sect->lma > info->limit))
    return;

  /*
  ** create a new element
  */
  new = ((struct pic30_section *) 
         xmalloc(sizeof(struct pic30_section)));
  new->sec  = sect;

  /* insert it at the right spot */
  prev = psv_sections;
  for (s = prev; s != NULL; s = s->next)
    {
      if (s->sec && (new->sec->_raw_size > s->sec->_raw_size))
        {
          prev->next = new;
          new->next = s;
          done++;
          break;
        }
      prev = s;
    }

  if (!done)
    {
      prev->next = new;
      new->next = NULL;
    }
} /* static void pic30_build_psv_section_list (...) */


/*
** Build a list of CODE sections
**  in order of decreasing size
**
** - this function is called via bfd_map_over_sections()
*/
static void
pic30_build_code_section_list (abfd, sect, p)
     bfd *abfd ATTRIBUTE_UNUSED ;
     asection *sect;
     PTR p;
{
  struct lma_adjust_info *info = (struct lma_adjust_info *) p;
  struct pic30_section *new, *s, *prev;
  int done = 0;

  /*
  ** exit if not CODE, or below threshold, or above limit
  */
  int isCODE = PIC30_IS_CODE_ATTR(sect);
  if (!isCODE || (sect->lma < info->base) || (sect->lma >= info->limit))
    return;

  /* create a new element */
  new = ((struct pic30_section *) 
         xmalloc(sizeof(struct pic30_section)));
  new->sec  = sect;

  /* insert it at the right spot */
  prev = code_sections;
  for (s = prev; s != NULL; s = s->next)
    {
      if (s->sec && (new->sec->_raw_size > s->sec->_raw_size))
        {
          prev->next = new;
          new->next = s;
          done++;
          break;
        }
      prev = s;
    }

  if (!done)
    {
      prev->next = new;
      new->next = NULL;
    }
} /* static void pic30_build_code_section_list (...) */


/*
** Create a list of free memory blocks
**
** - first item is null
*/
static void
pic30_init_memory_list(lst)
     struct pic30_memory **lst;
{
  *lst = ((struct pic30_memory *)
         xmalloc(sizeof(struct pic30_memory)));
  (*lst)->next = 0;
  (*lst)->addr = 0;
  (*lst)->size = 0;
  (*lst)->offset = 0;
}


/*
** Add a node to a memory list
**  in order of increasing size
*/
static void
pic30_add_to_memory_list (lst, addr, size)
     struct pic30_memory *lst;
     bfd_vma addr, size;
{
  struct pic30_memory *new, *b, *prev;
  int done = 0;

  /* create a new element */
  new = ((struct pic30_memory *) 
         xmalloc(sizeof(struct pic30_memory)));
  new->addr  = addr;
  new->size  = size;
  new->offset = 0;

  /* insert it at the right spot */
  prev = lst;
  for (b = prev; b != NULL; b = b->next)
    {
      if (new->size < b->size)
        {
          prev->next = new;
          new->next = b;
          done++;
          break;
        }
      prev = b;
    }

  if (!done)
    {
      prev->next = new;
      new->next = NULL;
    }
} /* static void pic30_add_to_memory_list (..) */


/*
** Find a suitable free block - static
**
** This function scans the free memory list
** looking for a buffer that will accomodate
** a static section (fixed address).
**
** If a suitable block is found, fill in the
** offset field to reflect the section starting
** address and return the block.
**
** If a suitable block can not be found, return NULL.
*/
static struct pic30_memory *
pic30_static_assign_memory (lst, size, address)
     struct pic30_memory *lst;
     bfd_vma size, address;
{
  struct pic30_memory *b, *prev;
  bfd_vma offset;

  prev = lst;
  for (b = prev; b != NULL; b = b->next)
    {
      if ((b->size < size) || (b->addr > address))
        continue;

      offset = address - b->addr;
      if (b->size >= (offset + size))
        {
          b->offset = offset;
          return b;
        }
    }

  /*
  ** if we get here, a suitable block could not be found
  */
  return (struct pic30_memory *) NULL;
} /* static struct pic30_memory * pic30_static_assign_memory (...) */


/*
** Find a suitable free block
**
** This function scans the free memory list
** looking for the best fit based on section
** size, alignment power, and PSV status.
**
** If a suitable block is found, fill in the
** offset field to reflect the section starting
** address and return the block.
**
** If a suitable block can not be found, return NULL.
*/
static struct pic30_memory *
pic30_best_fit_memory (lst, size, align_power, psv)
     struct pic30_memory *lst;
     bfd_vma size;
     unsigned int align_power;
     bfd_boolean psv;
{
  struct pic30_memory *b;
  bfd_vma mask = ~((~0) << align_power);
  bfd_vma new_address, new_size, next_page;
  bfd_vma align_offset, page_offset;

  for (b = lst; b != NULL; b = b->next)
    {
      if (b->size < size)
        continue;

      /* compute alignment offset */
      new_address = (b->addr + mask) & (~mask);
      align_offset = new_address - b->addr;

#if 0
      printf("\nalign_power = %x\n", align_power);
      printf("mask = %lx\n", mask);
      printf("block addr = %lx\n", b->addr);
      printf("new_address = %lx\n", new_address);
      printf("align_offset = %lx\n", align_offset);
#endif

      /* compute page blocking offset */
      page_offset = 0;
      if (psv)
        {
          next_page = ((b->addr + align_offset) & ~ 0x7FFF) + 0x8000;
          if ((b->addr + align_offset + size) > next_page)
            {
              /*
              ** This block will cross a PSV page boundary, so we
              ** must advance to the next page. Page boundaries (2^15)
              ** will satisfy any section alignment requirement. 
              */
              page_offset = next_page - (b->addr + align_offset);
#if 0
              printf("next_page = %lx\n", next_page);
              printf("page_offset = %lx\n", page_offset);
#endif
            }
        }

      /* see if this block meets all requirements */
      new_size = size + align_offset + page_offset;
      if (b->size >= new_size)
        {
          /* if so, fill in offset and return it */
          b->offset = align_offset + page_offset;
          return b;
        }
    } /* for (b = prev; b != NULL; b = b->next) */

  /*
  ** if we get here, a suitable block could not be found
  */
  return (struct pic30_memory *) NULL;
} /* static struct pic30_memory * pic30_best_fit_memory (...) */


/*
** Remove a block from a memory list
*/
static void
pic30_remove_from_memory_list (lst, block)
     struct pic30_memory *lst;
     struct pic30_memory *block; 
{
  struct pic30_memory *b, *prev, *next;

  prev = lst;
  for (b = prev; b != NULL; b = next)
    {
      next = b->next;
      if (b == block)
        {
          prev->next = next;
          free(b);
          break;
        }
      prev = b;
    }

} /* static void pic30_remove_from_memory_list(..) */


/*
** Free a memory list
*/
static void
pic30_free_memory_list(lst)
     struct pic30_memory **lst;
{
  struct pic30_memory *s, *next;

  if (!(*lst))
    return;

  for (s = *lst; s != NULL; s = next)
    {
      next = s->next;
      free(s);
    }

  *lst = NULL;
} /* static void pic30_free_memory_list (...) */


/*
 * See if a section name matches
 * the unique section list. Truncate
 * section names at the % char, which
 * is used to differentiate orphan sections
 * with the same names.
 */
static bfd_boolean
pic30_unique_section(const char *s)
{
  struct unique_sections *unam;
  const char *us;

  for (unam = unique_section_list; unam; unam = unam->next) {
    us = unam->name;
    while (*us) {
      if (*us++ != *s++) continue;
      if ((*s == '%') || (*s == '0'))  return TRUE;
    }
  }
  return FALSE;
}

/* include the improved memory allocation functions */
#include "../bfd/pic30-allocate.c"

/*****************************************************************************
**
** Utility Routines
**
** These functions are called at various
** points in the emulation.
**
*/


/*
** Load in the relocs for a section
*/
static arelent **
bfd_pic30_load_relocs (abfd, sec, syms)
     bfd *abfd;
     asection *sec;
     asymbol **syms;
{
  long relsize;
  arelent **relpp;

  relcount = 0;  /* default, no relocs in this section */

  if ((bfd_is_abs_section (sec)) ||
      (bfd_is_und_section (sec)) ||
      (bfd_is_com_section (sec)) ||
      (sec->flags & SEC_RELOC) == 0)
    return NULL;

  /* get the size needed for a reloc buffer */
  relsize = bfd_get_reloc_upper_bound (abfd, sec);
  if (relsize < 0)
    {
      fprintf( stderr, "Link Error: can't read relocs from %s\n",
               (char *) bfd_get_filename (abfd));
      abort();
    }

  if (relsize == 0)
    return NULL;
  else
    {
      /* get a buffer to hold the relocs */
      relpp = (arelent **) malloc (relsize);
      if (!relpp)
        {
          fprintf( stderr, "Link Error: not enough memory for relocs\n");
          abort();
        }

#if 0
      /*
      ** load the symbol table
      */
      syms = _bfd_generic_link_get_symbols (abfd);
#endif

      /* canonicalize the relocs */
      relcount = bfd_canonicalize_reloc (abfd, sec, relpp, syms);

      /* check for errors */
      if (relcount < 0)
        {
          fprintf( stderr, "Link Error: can't canonicalize relocs from %s\n",
                   (char *) bfd_get_filename (abfd));
          abort();
        }
      else if (relcount == 0)
        {
          free (relpp);
          return NULL;
        }
      else
        return (relpp);
    }
} /* static arelent ** bfd_pic30_load_relocs (...)*/


/*
** Add a symbol to the handle hash table
*/
static void
bfd_pic30_add_handle_sym(sym, flags)
     const char * sym;
     flagword flags;
{
  struct handle_hash_entry * handle;
  char *name;

  /* if no hash table exists, create one */
  if (!handles)
    handles = handle_hash_init();
    
  /* if we already have this entry... */
  handle = handle_hash_lookup (handles, sym, 0, 0);
  if (handle) {
    if ((pic30_debug) && (flags != handle->flags)) {
      printf("Hash handle for %s exists oldflags = 0x%x, new == 0x%x\n",
             handle->flags, flags);
    }
    return; /* simply return */
  }

  /* else make a permanent copy of the symbol name */
  name = (char *) bfd_alloc (output_bfd, (strlen (sym) + 1));
  if (!name)
    {
      fprintf( stderr, "Link Error: not enough memory for handle sym\n");
      abort();
    }
  strcpy( name, sym);

  if (pic30_debug)
    printf("  Adding handle %s  %x\n", name, handles->num);

  /* create a new handle for this symbol */
  handle = handle_hash_lookup (handles, name, 1, 0);

  /* initialize it */
  handle->index = handles->num++;
  handle->sym   = name;
  handle->flags = flags;

} /* static void bfd_pic30_add_handle_sym (...)*/


/*
** Create a new section
*/
static asection *
bfd_pic30_create_section (abfd, name, flags, align)
     bfd *abfd;
     const char *name;
     int flags;
     int align;
{
  asection *sec;
  asymbol *sym;

  if (pic30_debug) 
    printf("\nCreating input section \"%s\"\n", name);

  /* do NOT call bfd_make_section_old_way(), its buggy! */
  sec = bfd_make_section_anyway (abfd, name);
  bfd_set_section_flags (abfd, sec, flags | SEC_ALLOC | SEC_LOAD | SEC_KEEP);
  bfd_set_section_alignment (abfd, sec, align);
  sec->output_section = sec;

  /* add a symbol for the section name */
  sym = bfd_make_empty_symbol (abfd);
  symtab[symptr++] = sym;
  sym->name = sec->name;
  sym->section = sec;
  sym->flags = BSF_LOCAL;
  sym->value = 0;

  return sec;
} /* static asection * bfd_pic30_create_section (...)*/


/*
** Create a new symbol
**
** Uses the following global variables:
**   symtab
**   symptr
*/
static void
bfd_pic30_create_symbol (abfd, name, sec, flags, addr)
     bfd *abfd;
     char *name;
     asection *sec;
     int flags;
     int addr;
{
  asymbol *sym;

  if (pic30_debug)
  {
    printf("  Adding symbol %s\n", name);
  }
  sym = bfd_make_empty_symbol (abfd);
  sym->name = name;
  sym->section = sec;
  sym->flags = flags;
  sym->value = addr;
  symtab[symptr++] = sym;
} /* static void bfd_pic30_create_symbol (...)*/


/*
** Create a new relocation
**
** Uses the following global variables:
**   symtab
**   reltab
**   relcnt
**   relsize
*/
static void
bfd_pic30_create_reloc (abfd, address, which_howto, symidx)
     bfd *abfd;
     int address;
     int which_howto;
     int symidx;
{
  if (relcnt >= (relsize - 1))
    {
      relsize += 10;
      if (reltab)
        {
          if (pic30_debug)
            printf("  Resizing the reloc table %x\n", relsize * sizeof (arelent));
          reltab = (arelent *) bfd_realloc (reltab, relsize * sizeof (arelent));
        }
      else
	reltab = (arelent *) bfd_malloc (relsize * sizeof (arelent));
    }
  reltab[relcnt].address = address;
  reltab[relcnt].addend = 0;
  reltab[relcnt].howto = bfd_reloc_type_lookup (abfd, which_howto);
  reltab[relcnt].sym_ptr_ptr = symtab + symidx;
#if 0
  if (pic30_debug)
    printf("  Added reloc for %s %lx\n",
           (*(reltab[relcnt].sym_ptr_ptr))->name,
           reltab[relcnt].address);
#endif
  relcnt++;
} /* static void bfd_pic30_create_reloc (...)*/


/*
** Save the reloc table into a section
**
** Uses the following global variables:
**   reltab
**   relcnt
**   relsize
*/
static void
bfd_pic30_save_relocs (asection *sec)
{
  int i;
#if 0
  printf("bfd_pic30_save_relocs: %d entries\n", relcnt);
#endif
  sec->relocation = reltab;
  sec->reloc_count = relcnt;
  sec->orelocation = (arelent **) bfd_alloc (output_bfd,
                                             (relcnt + 1) * sizeof (arelent *));
  for (i = 0; i < relcnt; i++)
    sec->orelocation[i] = sec->relocation + i;
  sec->orelocation[relcnt] = 0;
  sec->flags |= SEC_RELOC;
  reltab = 0;
  relcnt = relsize = 0;
} /* static void bfd_pic30_save_relocs (...)*/


/*
** Print a handle hash table entry 
**
** This routine is called by handle_hash_traverse()
*/
static bfd_boolean
bfd_pic30_dump_handle_entry (h, p)
     struct bfd_hash_entry *h;
     PTR p ATTRIBUTE_UNUSED;
{
  struct handle_hash_entry *handle = (struct handle_hash_entry *) h;

  printf("  %x\t%s\n", handle->index, handle->sym);

  /* traverse the entire hash table */
  return TRUE;
} /* static bfd_boolean bfd_pic30_dump_handle_entry (...)*/


/*
** Create a new jump table entry 
**
** This routine is called by handle_hash_traverse()
**
** Note: unlike other offsets and lengths, relocation
**       addresses are specified in bytes
**
** Uses the following global variables:
**   symtab
**   symptr
**   reltab
**   relcnt
**   relsize
*/
static bfd_boolean
bfd_pic30_create_jump_table_entry (h, p)
     struct bfd_hash_entry *h;
     PTR p;
{
  struct handle_hash_entry *handle = (struct handle_hash_entry *) h;
  struct traverse_hash_info *info = (struct traverse_hash_info *) p;

  /* create a symbol for the jump target */
  bfd_pic30_create_symbol (info->abfd,
                           handle->sym,
                           /* info->sec, BSF_GLOBAL, 0); */
                           bfd_und_section_ptr, handle->flags, 0);

  /* create two relocs for the jump target */
  bfd_pic30_create_reloc (info->abfd,
                          handle->index * 8,
                          BFD_RELOC_PIC30_PGM_ADDR_LSB, symptr - 1);
  bfd_pic30_create_reloc (info->abfd,
                          (handle->index * 8) + 4,
                          BFD_RELOC_PIC30_PGM_ADDR_MSB, symptr - 1);

  /* traverse the entire hash table */
  return TRUE;
} /* static bfd_boolean bfd_pic30_create_jump_table_entry (...)*/


static void
bfd_pic30_dump_symbol_table(bfd *abfd)
{
  long size, num,i;
  asymbol **symbols;

  printf("\nSymbols in bfd \"%s\":\n", abfd->filename);
  size = bfd_get_symtab_upper_bound (abfd);
  if (size < 0) {
    fprintf( stderr, "Link Error: error accessing symbol table\n");
    abort();
  }

  symbols = (asymbol **) bfd_alloc(output_bfd, size); /* do not free */
  if (!symbols) {
    fprintf( stderr, "Link Error: not enough memory for symbol table\n");
    abort();
  }

  num = bfd_canonicalize_symtab (abfd, symbols);
  if (num < 0) {
    fprintf( stderr, "Link Error: error processing symbol table\n");
    abort();
  }
  else
    for (i=0; i<num; i++)
      printf("  %s\n", bfd_asymbol_name(symbols[i]));
}


static void
bfd_pic30_dump_reloc_table(bfd *abfd, asection *sec)
{
  arelent **p;

  printf("\nRelocs in bfd \"%s\", section \"%s\":\n",
         abfd->filename, sec->name);
  /* FIXME - CAW */
  rels = bfd_pic30_load_relocs(abfd, sec, 0);
  for (p = rels; relcount && *p != (arelent *) NULL; p++, relcount--)
    {
      arelent *q = *p;
      DUMP_CANON_RELOC(q->howto->name, q);
    }
  free (rels);
}


/*
** Create a bfd for the handle jump table
**
** Uses the following global variables:
**   symtab
**   symptr
**   reltab
**   relcnt
**   relsize
*/
static bfd *
bfd_pic30_create_jump_table_bfd (parent)
     bfd *parent;
{
  bfd_size_type size, i;
  bfd *abfd;
  asection *sec;
  char *oname;
  unsigned char *d;
  int flags, align;

  struct traverse_hash_info info;
  struct traverse_hash_info *tinfo = &info;

  if (pic30_debug)
  {
      /*
      ** print out the handle hash table entries
      */
      printf("\nHash Table Entries:\n");
      handle_hash_traverse (handles, bfd_pic30_dump_handle_entry, (PTR) 0);
  }

  /*
  ** create a bare-bones bfd
  */
  oname = (char *) bfd_alloc (output_bfd, 20);
  sprintf (oname, "jump_table");
  abfd = bfd_create (oname, parent);
  bfd_find_target ("${OUTPUT_FORMAT}", abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_pic30, 0);

  /*
  ** create a symbol table (room for num+1 entries)
  */
  symptr = 0;
  symtab = (asymbol **) bfd_alloc (output_bfd,
                                   (handles->num + 1) * sizeof (asymbol *));

  /*
  ** create a bare-bones section for .handle
  */
  flags = SEC_CODE | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
  align = 1; /* 2^1 */
  sec = bfd_pic30_create_section (abfd, ".handle", flags, align);
  size = (bfd_size_type) handles->num * 8;
  bfd_set_section_size (abfd, sec, size);

  /*
  ** allocate memory for the jump table
  */
  handle_data = (unsigned char *) bfd_alloc (output_bfd, size);
  if (!handle_data)
  {
      fprintf( stderr, "Link Error: not enough memory for jump table\n");
      abort();
  }
  sec->contents = handle_data;

  /*
  ** fill it with GOTO opcodes
  */
  d = handle_data;
  for (i=0; i<size; i+=8)
  {
      *d++ = 0; *d++ = 0;
      *d++ = 0x04; *d++ = 0;
      *d++ = 0; *d++ = 0;
      *d++ = 0; *d++ = 0;
  }

  /*
  ** create symbols and relocs for all the handles
  */
  tinfo->abfd = abfd;
  tinfo->sec = sec;
  handle_hash_traverse (handles, bfd_pic30_create_jump_table_entry, tinfo);

  /*
  ** put in the relocs
  */
  bfd_pic30_save_relocs (sec);

  /*
  ** put in the symbol table
  */
  bfd_set_symtab (abfd, symtab, symptr);

  /*
  ** and the new section
  */
  bfd_set_section_contents (abfd, sec, handle_data, 0, size);

  /*
  ** finish it
  */
  if (!bfd_make_readable (abfd))
  {
        fprintf(stderr, "Link Error: "
	                "can't make jump table readable\n");
        abort();
  }

  if (pic30_debug) {
    bfd_pic30_dump_symbol_table(abfd);
    bfd_pic30_dump_reloc_table(abfd, sec);
  }

  return(abfd);
}


/*
** Create a bfd for the data init template
**
** Uses the following global variables:
**   symtab
**   symptr
*/
static bfd *
bfd_pic30_create_data_init_bfd (parent)
     bfd *parent ATTRIBUTE_UNUSED;
{
  bfd_size_type size;
  bfd *abfd;
  asection *sec;
  char *oname;
  int flags, align;

  /* create a bare-bones bfd */
  oname = (char *) bfd_alloc (output_bfd, 20);
  sprintf (oname, "data_init");
  abfd = bfd_create (oname, parent);
  bfd_find_target ("${OUTPUT_FORMAT}", abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_pic30, 0);

  /* create a symbol table (room for 1 entry) */
  symptr = 0;
  symtab = (asymbol **) bfd_alloc (output_bfd, sizeof (asymbol *));

  /*
  ** create a bare-bones section for .dinit
  */
  flags = SEC_CODE | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_KEEP;
  align = 1; /* 2^1 */
  sec = bfd_pic30_create_section (abfd, ".dinit", flags, align);
  size = 0; /* will update later */
  bfd_set_section_size (abfd, sec, size);

  /* put in the symbol table */
  bfd_set_symtab (abfd, symtab, symptr);

  /* will add section contents later */

  /* finish it */
  if (!bfd_make_readable (abfd))
    {
      fprintf( stderr, "Link Error: can't make data init readable\n");
      abort();
    }

  return abfd;
} /* static bfd * bfd_pic30_create_data_init_bfd (...)*/


/*
** Create a bfd for the default interrupt handler
**
** Uses the following global variables:
**   symtab
**   symptr
*/
static bfd *
bfd_pic30_create_default_isr_bfd  (parent)
     bfd *parent;
{
  bfd_size_type size;
  bfd *abfd;
  asection *sec;
  char *oname;
  unsigned char *d;
  int flags, align;

  /* create a bare-bones bfd */
  oname = (char *) bfd_alloc (output_bfd, 20);
  sprintf (oname, "default_isr");
  abfd = bfd_create (oname, parent);
  bfd_find_target ("${OUTPUT_FORMAT}", abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_pic30, 0);

  /* create a symbol table (room for 2 entries) */
  symptr = 0;
  symtab = (asymbol **) bfd_alloc (output_bfd, 2 * sizeof (asymbol *));

  /*
  ** create a bare-bones section for the .isr section
  */
  flags = SEC_CODE | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
  align = 1; /* 2^1 */
  sec = bfd_pic30_create_section (abfd, ".isr", flags, align);
  size = (bfd_size_type) 8;
  bfd_set_section_size (abfd, sec, size);

  /* allocate memory */
  isr_data = (unsigned char *) bfd_alloc (output_bfd, size);
  if (!isr_data)
    {
      fprintf( stderr, "Link Error: not enough memory for default isr\n");
      abort();
    }
  sec->contents = isr_data;

  /* fill it with BREAK; RESET opcode */
  d = isr_data;
  /* BREAK */
  *d++ = 0x00; *d++ = 0x40;
  *d++ = 0xDA; *d++ = 0x00;
  /* RESET */
  *d++ = 0; *d++ = 0;
  *d++ = 0xFE; *d++ = 0;

  /* create global label at offset zero */
  bfd_pic30_create_symbol (abfd, "__DefaultInterrupt", sec,
                           BSF_GLOBAL | BSF_FUNCTION, 0);

  /* put in the symbol table */
  bfd_set_symtab (abfd, symtab, symptr);

  /* and the new section */
  bfd_set_section_contents (abfd, sec, isr_data, 0, size);

  /* finish it */
  if (!bfd_make_readable (abfd))
      {
        fprintf( stderr, "Link Error: can't make default isr readable\n");
        abort();
      }

  return abfd;
} /* static bfd * bfd_pic30_create_default_isr_bfd (...)*/


/*
** Create a bfd for the user_init function terminator
**
** Uses the following global variables:
**   symtab
**   symptr
*/
static bfd *
bfd_pic30_create_user_init_bfd  (bfd *parent)
{
  bfd_size_type size;
  bfd *abfd;
  asection *sec;
  char *oname;
  unsigned char *d;

  /* create a bare-bones bfd */
  oname = (char *) bfd_alloc (output_bfd, 20);
  sprintf (oname, "the_terminator");
  abfd = bfd_create (oname, parent);
  bfd_find_target ("coff-pic30", abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_pic30, 0);

  /* create a symbol table (room for 2 entries) */
  symptr = 0;
  symtab = (asymbol **) bfd_alloc (output_bfd, 2 * sizeof (asymbol *));

  /* create a bare-bones section */
  sec = bfd_pic30_create_section (abfd, ".user_init",
                                  SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE, 1);
  size = (bfd_size_type) 4;
  bfd_set_section_size (abfd, sec, size);

  /* allocate memory */
  user_init_data = (unsigned char *) bfd_alloc (output_bfd, size);
  if (!user_init_data) abort();
  sec->contents = user_init_data;

  /* fill it with RETURN opcode */
  d = user_init_data;
  *d++ = 0; *d++ = 0;
  *d++ = 0x06; *d++ = 0;

  /* create global label at offset zero */
  //bfd_pic30_create_symbol (abfd, "__the_terminator", sec, BSF_GLOBAL, 0);

  /* put in the symbol table */
  bfd_set_symtab (abfd, symtab, symptr);

  /* and the new section */
  bfd_set_section_contents (abfd, sec, user_init_data, 0, size);

  /* finish it */
  if (!bfd_make_readable (abfd)) abort();

  return abfd;
} /* static bfd * bfd_pic30_create_user_init_bfd (...)*/


/*
** Create a bfd for a configuration word
**
** Uses the following global variables:
**   symtab
**   symptr
*/
static bfd *
bfd_pic30_create_config_word_bfd  (char *name, unsigned short val)
{
  bfd_size_type size;
  bfd *abfd;
  asection *sec;
  char *oname,*sec_name,*sec_data, *d;

  /* create a bare-bones bfd */
  oname = (char *) bfd_alloc (output_bfd, strlen(name) + 1);
  sprintf (oname, name);
  abfd = bfd_create (oname, output_bfd);
  bfd_find_target ("coff-pic30", abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_pic30, 0);

  /* create a symbol table (room for 2 entries) */
  symptr = 0;
  symtab = (asymbol **) bfd_alloc (output_bfd, 2 * sizeof (asymbol *));

  /* create a bare-bones section */
  sec_name = (char *) bfd_alloc (output_bfd, strlen(name) + 6 + 1);

  sprintf(sec_name, "__%s.sec", name);
  sec = bfd_pic30_create_section (abfd, sec_name,
                                  SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE, 1);
  size = (bfd_size_type) 4;
  bfd_set_section_size (abfd, sec, size);

  /* allocate memory */
  sec_data = (char *) bfd_alloc (output_bfd, size);
  if (!sec_data) abort();
  sec->contents = (unsigned char *) sec_data;

  /* fill it with config word value (16 valid bits, padded to 32) */
  d = sec_data;
  *d++ = val & 0xFF; *d++ = val >> 8;
  *d++ = 0; *d++ = 0;

  /* create global label at offset zero */
  bfd_pic30_create_symbol (abfd, sec_name, sec, BSF_GLOBAL, 0);

  /* put in the symbol table */
  bfd_set_symtab (abfd, symtab, symptr);

  /* and the new section */
  bfd_set_section_contents (abfd, sec, sec_data, 0, size);

  /* finish it */
  if (!bfd_make_readable (abfd)) abort();

  return abfd;
} /* static bfd * bfd_pic30_create_config_word_bfd (...)*/


/*
** Create a bfd for the heap
**
** Uses the following global variables:
**   symtab
**   symptr
**   pic30_heap_size
*/
static bfd *
bfd_pic30_create_heap_bfd (bfd *parent) {
  bfd_size_type size;
  bfd *abfd;
  asection *sec;
  char *oname;
  int flags, align;

  /* create a bare-bones bfd */
  oname = (char *) bfd_alloc (output_bfd, 20);
  sprintf (oname, "heap");
  abfd = bfd_create (oname, parent);
  bfd_find_target ("coff-pic30", abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_pic30, 0);

  /* create a symbol table (room for 1 entry) */
  symptr = 0;
  symtab = (asymbol **) bfd_alloc (output_bfd, sizeof (asymbol *));

  /* create a bare-bones section */
  flags = SEC_ALLOC;
  align = 1;
  sec = bfd_pic30_create_section (abfd, ".heap", flags, align);
  size = pic30_heap_size * 2; /* allow for phantoms */
  bfd_set_section_size (abfd, sec, size);

  /* put in the symbol table */
  bfd_set_symtab (abfd, symtab, symptr);

  /* finish it */
  if (!bfd_make_readable (abfd)) {
      fprintf( stderr, "Link Error: can't make heap readable\n");
      abort();
    }

  /* must set this attribute last, because the call to
     bfd_make_readable() loses extended attributes */
  PIC30_SET_HEAP_ATTR(abfd->sections);

  abfd->sections->flags |= SEC_KEEP;

  return abfd;
} /* static bfd * bfd_pic30_create_heap_bfd (...)*/


/*
** Count the number of active entries in map[num]
*/
static int
active_entries(char *map, int num)
{
  int i, cnt = 0;

  if (map == NULL) return num;
  for (i=0; i<num; i++)
    if (map[i]) cnt++;
  return cnt;
}

/*
** generate a name for an access
** entry symbol
*/
static char *
access_entry_name(const char *base, int slot)
{
  char *s;
  const char *s2 = "_entry:";

  s = xmalloc( 2 + strlen(base) + strlen(s2) + 4 + 1);
  sprintf(s, "__%s%s%d", base, s2, slot);
  return s;
}


/*
** generate a name for an access
** entry target symbol
*/
static char *
access_target_name(const char *base, int slot)
{
  char *s;
  const char *s2 = "_func:";

  s = xmalloc( 2 + strlen(base) + strlen(s2) + 4 + 1);
  sprintf(s, "__%s%s%d", base, s2, slot);
  return s;
}


/*
** generate a name for a generic access
** entry target symbol
*/
static char *
generic_access_target_name(const char *base)
{
  char *s;
  const char *s2 = "_func:unused";

  s = xmalloc( 2 + strlen(base) + strlen(s2) + 1);
  sprintf(s, "__%s%s", base, s2);
  return s;
}


/*
** generate a name for a isr access
** entry target symbol
*/
static char *
isr_access_target_name(const char *base)
{
  char *s;
  const char *s2 = "_func:isr";

  s = xmalloc( 2 + strlen(base) + strlen(s2) + 1);
  sprintf(s, "__%s%s", base, s2);
  return s;
}


/*
** Create a bfd for a branch table
**
** name: base name for table and associated symbols
** addr: memory address
** num:  number of entries in the table
** map:  integer array to indicate which entries are active
**       - for each element: 1=active, 0=empty
**       - if the array pointer is NULL, all entries active
** parent: parent bfd
**
** Uses the following global variables:
**   symtab
**   symptr
**   reltab
**   relcnt
**   relsize
**   boot_flash_base
**   secure_flash_base
*/
static bfd *
bfd_pic30_create_branch_table_bfd (char *name, bfd_vma addr,
                                   int num, char *map, bfd *parent,
                                   bfd_boolean has_default,
                                   bfd_boolean has_isr)
{
#define ACCESS_ENTRY_ISR_SLOT 16
  int size, i;
  bfd *abfd;
  char *oname;
  asection *sec;
  unsigned char *d,*tab;
  int default_access_target_symbol = 0;

  if (pic30_debug)
    printf("\nCreating branch table \"%s\"\n", name);

  /* create a bare-bones bfd */
  oname = (char *) bfd_alloc (parent, strlen(name) + 1);
  sprintf (oname, name);
  abfd = bfd_create (oname, parent);
  bfd_find_target ("coff-pic30", abfd);
  bfd_make_writable (abfd);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_pic30, 0);

  /* create a symbol table (room for (num*2)+3 entries) */
  symptr = 0;
  symtab = (asymbol **) bfd_alloc (output_bfd,
                                   (((active_entries(map, num)*2) + 3) *
                                    sizeof (asymbol *)));

  /* create a bare-bones section */
  sec = bfd_pic30_create_section (abfd, name,
                                  SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE, 1);
  size = num * 4;
  bfd_set_section_size (abfd, sec, size);
  PIC30_SET_ABSOLUTE_ATTR(sec);
  if (strcmp(name, ".boot") == 0) PIC30_SET_BOOT_ATTR(sec);
  if (strcmp(name, ".secure") == 0) PIC30_SET_SECURE_ATTR(sec);
  sec->vma = addr;
  sec->lma = addr;

  /* allocate memory for the table */
  tab = (unsigned char *) bfd_alloc (output_bfd, size);
  if (!tab)
    {
      fprintf( stderr, "Link Error: not enough memory for branch table\n");
      abort();
    }
  sec->contents = tab;

  /* fill it with BRA opcodes or space for isr vector */
  d = tab;
  for (i=0; i<size; i+=4)
    {
      *d++ = 0; *d++ = 0;  /* 2 LS bytes */
      if (has_isr && (i == ACCESS_ENTRY_ISR_SLOT * 4))
        *d++ = 0;
      else
        *d++ = 0x37;
      *d++ = 0;           /* phantom byte */
    }

  if (has_default) {
    /* a target for the generic active entry */
    bfd_pic30_create_symbol(abfd, generic_access_target_name(name+1),
                            bfd_und_section_ptr, BSF_GLOBAL, 0);
    default_access_target_symbol = symptr - 1;
  }

  /* create symbols and relocs for each entry */
  for (i=0; i<num; i++)
    if (has_isr && (i == ACCESS_ENTRY_ISR_SLOT)) {
      /* a target for the isr entry */
      bfd_pic30_create_symbol(abfd, isr_access_target_name(name+1),
                              bfd_und_section_ptr, BSF_GLOBAL, 0);
      /* a relocation of type BFD_RELOC_PIC30_PGM_ADDR_LSB */
      bfd_pic30_create_reloc(abfd, i*4,
                             BFD_RELOC_PIC30_PGM_ADDR_LSB, symptr - 1 );
    }
    /* else if entry is active, i.e. defined */
    else if ((map == NULL) || (map[i] != 0)) {
      /* FIXME: if relocations are resolved properly, no
         definition is needed for access entries, so
         this label shouldn't need to be defined. */
      /* a label for each active entry */
      bfd_pic30_create_symbol(abfd, access_entry_name(name+1, i),
                              sec, BSF_GLOBAL, i*2);
      /* a target for each active entry */
      bfd_pic30_create_symbol(abfd, access_target_name(name+1, i),
                              bfd_und_section_ptr, BSF_GLOBAL, 0);
      /* relocation of type BFD_RELOC_PIC30_PCREL_BRANCH */
      bfd_pic30_create_reloc(abfd, i*4,
                             BFD_RELOC_PIC30_PCREL_BRANCH, symptr - 1 );
    }
    else if (has_default) {
      /* create a reference to the default access entry target */
      /* relocation of type BFD_RELOC_PIC30_PCREL_BRANCH */
      bfd_pic30_create_reloc(abfd, i*4,
                             BFD_RELOC_PIC30_PCREL_BRANCH,
                             default_access_target_symbol);
    }


  /* put in the relocs */
  bfd_pic30_save_relocs (sec);


  /* put in the symbol table */
  bfd_set_symtab (abfd, symtab, symptr);


  /* and the new section */
  bfd_set_section_contents (abfd, sec, tab, 0, size);

  /* finish it */
  if (!bfd_make_readable (abfd))
      {
        fprintf( stderr, "Link Error: can't make branch table readable\n");
        abort();
      }

  if (pic30_debug) {
    bfd_pic30_dump_symbol_table(abfd);
    bfd_pic30_dump_reloc_table(abfd, sec);
  }

  return abfd;
} /* static bfd * bfd_pic30_create_branch_table_bfd (...)*/


/*
** Add a new bfd to the link
*/
static void
bfd_pic30_add_bfd_to_link (abfd, name)
     bfd *abfd;
     const char *name;
{
  lang_input_statement_type *fake_file;
  fake_file = lang_add_input_file (name,
				   lang_input_file_is_fake_enum,
				   NULL);
  fake_file->the_bfd = abfd;
  ldlang_add_file (fake_file);
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo (_("%F%B: could not add symbols: %E\n"), abfd);

  return;
} /* static void bfd_pic30_add_bfd_to_link (...)*/


/*
** This routine is called by before_allocation().
**
** Scan a DATA or BSS section and accumulate
** the data template size.
*/
static void
bfd_pic30_scan_data_section (sect, p)
     asection *sect;
     PTR p;
{
#define DATA_RECORD_HEADER_SIZE 12

  int *data_size = (int *) p;

  if (p == (int *) NULL)
    return;

  /*
  ** skip persistent or noload data sections
  */
  if (PIC30_IS_PERSIST_ATTR(sect) | PIC30_IS_NOLOAD_ATTR(sect))
  {
      /*
      ** issue a warning if DATA values are present
      */
      if ((sect->flags & SEC_DATA) && (sect->_raw_size > 0))
        einfo(_("%P: Warning: initial values were specified for a non-loadable"
                " data section (%s). These values will be ignored.\n"),
              sect->name);

      if (pic30_debug)
        printf("  %s (skipped), size = %x bytes\n",
               sect->name, (unsigned int) sect->_raw_size / 2);
      return;
  }

  /*
  ** process BSS-type sections
  */
  if (PIC30_SECTION_IS_BSS_TYPE(sect) &&
      (sect->_raw_size > 0))
  {
      *data_size += DATA_RECORD_HEADER_SIZE;
      if (pic30_debug)
        printf("  %s (bss), size = %x bytes, template += %x pwords\n",
               sect->name, (unsigned int) sect->_raw_size / 2,
               DATA_RECORD_HEADER_SIZE / 4);
  }

  /*
  ** process DATA-type sections
  */
  if (PIC30_IS_DATA_ATTR(sect) && (sect->_raw_size > 0))
  {
      int count = sect->_raw_size / 2; /* ignore phantom in data image */
      int delta = DATA_RECORD_HEADER_SIZE +
                  (pic30_pack_data ? (((count + 2) / 3) * 4) :
                                     (((count + 1) / 2) * 4));
      *data_size += delta;
      
      /*
      ** make section not LOADable
      */
      sect->flags &= ~ SEC_LOAD;

      if (pic30_debug)
        printf("  %s (data), size = %x bytes, template += %x pwords\n",
               sect->name, (unsigned int) sect->_raw_size / 2, delta / 4);
  }
} /*static void bfd_pic30_scan_data_section (...)*/


/*
** This routine is called by before_allocation()
** when the --no-data-init option is specified.
**
** Scan for loadable DATA sections...if found,
** mark them NEVER_LOAD and issue a warning.
*/
static void
bfd_pic30_skip_data_section (sect, p)
     asection *sect;
     PTR p ATTRIBUTE_UNUSED ;
{
  /*
  ** process DATA-type sections
  */
  if (((sect->flags & SEC_DATA) == SEC_DATA) && (sect->_raw_size > 0))
  {      
      /*
      ** make section not LOADable
      */
      sect->flags &= ~ SEC_LOAD;
      sect->flags |= SEC_NEVER_LOAD;

      /*
      ** issue a warning
      */
      einfo(_("%P: Warning: data initialization has been turned off,"
              " therefore section %s will not be initialized.\n"), sect->name);

      if (pic30_debug)
        printf("  %s (skipped), size = %x\n",
               sect->name, (unsigned int) sect->_raw_size / 2);
  }
}

/*
** Print diagnostic section info
*/
static void
bfd_pic30_print_section_header()
{
  printf("  %8s %5s %6s %6s %6s\n",
         " section", "flags", "   VMA", "   LMA", "length");
  printf("  %8s %4s %6s %6s %6s\n",
         " -------", "-----", "------", "------", "------");
}

static void
bfd_pic30_report_sections (abfd, sect, fp) 
     bfd *abfd;
     asection *sect;
     PTR fp ATTRIBUTE_UNUSED ;
{
  printf("  %8s %5x %6x %6x %6x %s\n", sect->name, sect->flags,
         (unsigned int) sect->vma,
         (unsigned int) sect->lma,
         (unsigned int) sect->_raw_size / bfd_octets_per_byte (abfd),
         sect->user_set_vma ? "(fixed)" : "");
  return;
}


/*
** Strip zero-length sections
*/
static void
pic30_strip_sections (abfd)
     bfd *abfd;
{
  asection *sec, *prev;
  
  if (pic30_debug)
    printf("\nLooking for zero-length sections:\n");

  sec = abfd->sections;
  if ((sec == NULL) || (sec->next == NULL))
    return;

  prev = sec;
  sec = sec->next; /* never strip the first section */

  /* loop through the sections in this bfd */
  for (; sec != NULL; sec = sec->next)
    {
      /* remove sections with size = 0 */
      if (sec->_raw_size == 0)
        {
        prev->next = sec->next;
        abfd->section_count -= 1;
        if (pic30_debug)
          printf("  Stripping section %s\n", sec->name);
        }
      else
        prev = sec;
    }
  return;
} /* static void pic30_strip_sections (...)*/


/*
** Return a pointer to bfd_link_hash_entry
** if a global symbol is defined;
** else return zero.
*/
struct bfd_link_hash_entry *
bfd_pic30_is_defined_global_symbol (name)
     const char *const name;
{
    struct bfd_link_hash_entry *h;
    h = bfd_link_hash_lookup (link_info.hash, name, FALSE, FALSE, TRUE);

    if ((h != (struct bfd_link_hash_entry *) NULL) &&
        (h->type == bfd_link_hash_defined))
      return h;
    else
      return (struct bfd_link_hash_entry *) NULL;
}


/*
** Re-define a global symbol
*/
static void
bfd_pic30_redefine_global_symbol (name, sec, value)
     const char *const name;
     asection *sec;
     bfd_vma value;
{
  struct bfd_link_hash_entry *h;
  h = bfd_link_hash_lookup (link_info.hash, name, FALSE, FALSE, TRUE);
  if ((h != (struct bfd_link_hash_entry *) NULL) &&
      ((h->type == bfd_link_hash_defined) || (h->type == bfd_link_hash_defweak)))
    {
      /* symbol is defined, re-define it */
      if (pic30_debug)
        {
          printf("\nRe-defining symbol %s, section was %s, value was %lx\n",
                 name, h->u.def.section->name, h->u.def.value);
          printf("  New values: section %s, value %lx\n", sec->name, value);
        }
      h->u.def.section = sec;
      h->u.def.value = value;
    }
}

/*
** Undefine one symbol by BFD
**
** This routine is called by bfd_link_hash_traverse()
*/
static bfd_boolean
bfd_pic30_undefine_one_symbol_bfd (h, p)
     struct bfd_link_hash_entry *h;
     PTR p;
{
  struct bfd_link_hash_entry *H = (struct bfd_link_hash_entry *) h;
  struct traverse_hash_info *info = ( struct traverse_hash_info *) p;

  /* if this symbol is defined, and owned by the BFD in question */
  if ((( H->type == bfd_link_hash_defined) ||
       ( H->type == bfd_link_hash_defweak)) &&
      ( H->u.def.section->owner == info->abfd))

    /* mark it undefined */
    H->type = bfd_link_hash_undefined;
 
  /* traverse the entire hash table */
  return TRUE;
} /* static bfd_boolean bfd_pic30_undefine_one_symbol_bfd (...)*/


/*
** Undefine all symbols owned by an bfd
*/
static void
bfd_pic30_undefine_symbols_bfd (target)
     bfd *target;
{
    struct traverse_hash_info info;
    info.abfd = target;

    /* traverse the global linker hash table */
    bfd_link_hash_traverse (link_info.hash,
			    bfd_pic30_undefine_one_symbol_bfd, &info);

} /* static void bfd_pic30_undefine_symbols_bfd (...) */


/*
** Remove an archive module
*/
static void
bfd_pic30_remove_archive_module (name)
     const char *const name;
{
  LANG_FOR_EACH_INPUT_STATEMENT (is)
  {
      if (strcmp (is->the_bfd->filename, name) == 0)
      {
          if (pic30_debug)
          {
              printf("\nRemoving %s\n", name);
              printf("  %s had %d symbols\n", name , is->the_bfd->symcount);
          }

          /*
	  ** remove the symbols
	  */
          bfd_pic30_undefine_symbols_bfd (is->the_bfd);
          is->the_bfd->symcount = 0;

          /*
	  ** remove the sections in this bfd
	  */
	  bfd_section_list_clear(is->the_bfd);
          break;
      }
  }
}

/*
** Print memory region info
*/
static void
bfd_pic30_print_region_info (name)
     const char *const name;
{
  lang_memory_region_type *region;

  region = lang_memory_region_lookup (name);
  printf("  %s: start = %x, len = %x, current = %x\n", region->name,
         (unsigned int) region->origin,
         (unsigned int) region->length,
         (unsigned int) region->current);
  return;
}

/*****************************************************************************
**
** Emulation Routines
**
** These functions are called directly
** by entry points in the emulation transfer structure.
**
*/


/*
 * Emulation routine: bfd_pic30_before_parse
 *
 * - initialize data structures needed by the emulation
 *  
 */
static void
bfd_pic30_before_parse()
{
#if 0
  fprintf( stderr, "before_parse\n");
#endif
  /* don't let lang_process() change .text section flags */
  config.text_read_only = FALSE;
  /* Disable demand paging, otherwise program headers
     are sometimes corrupted. See for example linker
     unit tests reloc104, reloc105, and SSR# 27922.
     This may change file offsets in the output file,
     but not the contents of any section. */
  config.magic_demand_paged = FALSE;
}


/*
 * Emulation routine: bfd_pic30_after_parse
 *
 * This routine is called after the linker script has been read.
 *  
 */
static void
bfd_pic30_after_parse()
{
#if 0
  fprintf( stderr, "after_parse\n");
#endif

  if (pic30_startup0_file == 0) {
    if (pic30_is_eds_machine(global_PROCESSOR))
      pic30_startup0_file = "crt0_extended.o";
    else
      pic30_startup0_file = "crt0_standard.o";

    einfo(_("%P: Warning: linker script did not specify CRT0_STARTUP file,"
            " default for this device: %s\n"), pic30_startup0_file );
  }

  if (pic30_startup1_file == 0) {
    if (pic30_is_eds_machine(global_PROCESSOR))
      pic30_startup1_file = "crt1_extended.o";
    else
      pic30_startup1_file = "crt1_standard.o";
    einfo(_("%P: Warning: linker script did not specify CRT1_STARTUP file,"
            " default for this device: %s\n"), pic30_startup1_file );
  }
}


/*
 * Emulation routine: bfd_pic30_process_bfd_after_open
 *
 * This routine is called for each input bfd. It
 * loops through all the input sections and stores
 * handle relocations in a hash table. This table
 * is later used to construct the handle jump table.
 *
 * Sections named .comment have their ALLOC and LOAD
 * flags cleared.
 *
 * Also looks for an input file named sbrk.o. If found,
 * we know that a heap will be required at runtime.
 *
 * Validates the input file processor setting against
 * the target output setting.
 *
 * If any dma_offset() relocations are present,
 * make sure the dma address range is defined.
 *
 * Looks for __managed_psv flag, boot and/or
 * secure access slot definitions in the symbol
 * table.
 *
 * Look for .user_init sections.
 *
 * Look for a heap section.
 *
 * Look for user-defined memory regions,
 * and process accordingly.
 *
 * Decode extended section attributes.
 *
 */
static bfd_boolean
bfd_pic30_process_bfd_after_open (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  asection *sec;
  arelent **p;
  const char *sym_name;
  struct handle_hash_entry * handle;
  bfd_boolean file_printed = FALSE;
  asymbol **symbols = 0;
  bfd_boolean has_extended_attributes = FALSE;

  /*
  ** check the input file name
  */
  if (!strcmp(abfd->filename, "sbrk.eo"))
  {
      pic30_heap_required = 1;
  }

  /* validate the processor setting(s) */
  if (pic30_debug)
    printf("  input file %s, procID = %s\n",
           abfd->filename, abfd->arch_info->printable_name);

  if (!pic30_force_link &&
      (global_PROCESSOR != 0) &&
      (abfd->arch_info->mach != 0) &&
      (global_PROCESSOR != abfd->arch_info))
    {
      if (pic30_debug)
        printf("    checking for conflict between %s and %s\n",
               global_PROCESSOR->printable_name,
               abfd->arch_info->printable_name);

      if (!pic30_is_dsp_machine(global_PROCESSOR) &&
          pic30_is_dsp_machine(abfd->arch_info))
        einfo(_("%P%X: Error: object %s was created for the %s,"
                " which is not instruction set compatible with the target %s.\n"),
              abfd->filename,
              abfd->arch_info->printable_name,
              global_PROCESSOR->printable_name);
    }

  /*
  ** loop through the symbols in this bfd
  */
  {
    long size, num,i;
    char *s,*t;

    size = bfd_get_symtab_upper_bound (abfd);
    if (size < 0)
      abort();

    symbols = (asymbol **) xmalloc(size);
    if (!symbols)
      abort();

    num = bfd_canonicalize_symtab (abfd, symbols);
    if (num < 0)
      abort();
    
        
    for (i=0; i<num; i++) {

      char *ext_attr_prefix = "__ext_attr_";

      /*
       * Look for extended section attributes. If we find any,
       * store the info in a list for use below, where we loop
       * through the sections in this bfd.
       */
      sym_name = bfd_asymbol_name(symbols[i]);
      if (strstr(sym_name, ext_attr_prefix)) {
        char *sec_name = (char *) &sym_name[strlen(ext_attr_prefix)];
        bfd_vma attr = bfd_asymbol_value(symbols[i]);

        if (!has_extended_attributes) {
          pic30_init_symbol_list (&pic30_symbol_list);
          has_extended_attributes = TRUE;
        }

        pic30_add_to_symbol_list(&pic30_symbol_list, sec_name, attr);
        if (pic30_debug)
          printf("    extended attributes for section %s: 0x%lx\n",
                 sec_name, attr);
      }
        
      /* look for __managed_psv flag */
      if (PIC30_IS_INFO_ATTR(symbols[i]->section) &&
          strcmp(symbols[i]->section->name, "__c30_info") == 0) {
        sym_name = bfd_asymbol_name(symbols[i]);
        if (strstr(sym_name, "__managed_psv")) {
          pic30_has_managed_psv = TRUE;

          if (pic30_debug)
            printf("    %s\n", sym_name);
        }
      }

      /* look for __psv_trap_errata flag */
      if (PIC30_IS_INFO_ATTR(symbols[i]->section) &&
          strcmp(symbols[i]->section->name, "__c30_info") == 0) {
        sym_name = bfd_asymbol_name(symbols[i]);
        if (strstr(sym_name, "__psv_trap_errata")) {
          pic30_has_psv_trap_errata = TRUE;

          if (pic30_debug)
            printf("    %s\n", sym_name);

        }
      }

      /* look for a reference to PSVPAG or DSRPAG not in CRT */
      if (strncmp(abfd->filename, "crt", 3) != 0) {
        if ((strcmp(sym_name,"_PSVPAG") == 0) ||
            (strcmp(sym_name,".const") == 0) ||
            (strcmp(sym_name,"_DSWPAG") == 0) ||
            (strcmp(sym_name,"_DSRPAG") == 0)) {
          has_psvpag_reference = 1;
        }
      }

      /* look for secure segment access slot definitions */
      if (!PIC30_IS_BOOT_ATTR(symbols[i]->section) &&
          !PIC30_IS_SECURE_ATTR(symbols[i]->section))
        continue;

      sym_name = bfd_asymbol_name(symbols[i]);
      if (strstr(sym_name, "__boot_func:")) {

        has_boot_access = TRUE;
        s = strstr(sym_name, ":");

        if (pic30_debug)
          printf("    %s\n", sym_name);

        if (strstr(s, "unused")) {
          /* record unused boot slot definition */
          boot_unused_entry_defined = TRUE;
        }
        else if (strstr(s, "isr")) {
          /* record isr boot access slot definition */
          boot_isr_entry_defined = TRUE;
        }
        else {
          /* mark the access slot active */
          t = &boot_access[0];
          t[atoi(++s)] = 1;
        }
      }
      else if (strstr(sym_name, "__secure_func:")) {

        has_secure_access = TRUE;
        s = strstr(sym_name, ":");

        if (pic30_debug)
          printf("    %s\n", sym_name);

        if (strstr(s, "unused")) {
          /* record unused secure slot definition */
          secure_unused_entry_defined = TRUE;
        }
        else if (strstr(s, "isr")) {
          /* record isr secure access slot definition */
          secure_isr_entry_defined = TRUE;
        }
        else {
          /* mark the access slot active */
          t = &secure_access[0];
          t[atoi(++s)] = 1;
        }
      }
    }
  }

  /*
  ** loop through the sections in this bfd
  */
  for (sec = abfd->sections; sec != 0; sec = sec->next)
  {
    struct bfd_link_hash_entry *h;
    unsigned int old_attr = pic30_attribute_map(sec);
    bfd_boolean is_memory_region;
    static unsigned int region_index = 0;
    const char *region_name = 0;
#if 0
    if (pic30_debug)
      printf("  input section %s, %s\n",
             sec->name, pic30_section_attr_string(sec));
#endif

    /* if section has extended attributes, apply them */
    if (has_extended_attributes) {
      int i;
      for (i=0; i < pic30_symbol_count; i++) {
        if (strcmp(sec->name, pic30_symbol_list[i].name) == 0)
          pic30_set_extended_attributes(sec, pic30_symbol_list[i].value, 0);
      }
    }

    /* if section has PSV attribute, record that fact */
    if (PIC30_IS_PSV_ATTR(sec) && (sec->_raw_size > 0))
      has_psv_section = TRUE;

    /* if section has HEAP attribute, record that fact */
    if (PIC30_IS_HEAP_ATTR(sec) && (sec->_raw_size > 0)) {
      if (heap_section_defined)
        einfo(_("%P%X: Error: Multiple heap sections defined\n"));
      else {
        heap_section_defined = TRUE;
        heap_bfd = sec->owner;
        if ((pic30_heap_size > 0) &&
            (pic30_heap_size != (sec->_raw_size / 2)))
          einfo(_("%P%X: Error: Size of heap requested (%d bytes)"
                  " does not match heap defined in section \'%s\'"
                  "  (%d bytes)\n"), pic30_heap_size, sec->name,
                   sec->_raw_size /2 );
      }
    }

    /* if section has STACK attribute, record that fact */
    if (PIC30_IS_STACK_ATTR(sec) && (sec->_raw_size > 0)) {
      if (stack_section_defined)
        einfo(_("%P%X: Error: Multiple stack sections defined\n"));
      else {
        stack_section_defined = TRUE;
        stack_bfd = sec->owner;
        if ((pic30_stack_size > 0) &&
            (pic30_stack_size > (sec->_raw_size / 2)))
          einfo(_("%P%X: Error: Stack defined in section \'%s\'"
                  " (%d bytes) is less than the minumum (%d bytes)\n"),
                sec->name, sec->_raw_size/2, pic30_stack_size);
      }
    }

    /* if section is user_init, record that fact */
    if (strstr(sec->name, ".user_init"))
      has_user_init_functions = TRUE;

    /* if section represents a memory region, record it */
    is_memory_region = FALSE;
    if (PIC30_IS_INFO_ATTR(sec) &&
        strncmp(sec->name, memory_region_prefix,
                strlen(memory_region_prefix)) == 0) {
      region_name = sec->name + strlen(memory_region_prefix);

      is_memory_region = TRUE;
      region_index++;
      h = bfd_pic30_is_defined_global_symbol(region_name);
      if (h == NULL) {
        if (pic30_debug)
          printf("  ..creating global symbol for user-defined memory %s\n",
                 region_name);
        _bfd_generic_link_add_one_symbol (info, abfd,
                                         region_name, BSF_GLOBAL,
                                          bfd_abs_section_ptr, region_index,
                                          region_name, 1, 0, 0);
      }
    }
    
    /* process input section flags here, if necessary */
    if ((sec->flags & (SEC_ALLOC | SEC_LOAD | SEC_DATA)) ==
         (SEC_ALLOC | SEC_LOAD | SEC_DATA))
      sec->flags |= SEC_HAS_CONTENTS;  /* elf linker needs this */

    /* report if flags were changed */
     {
      unsigned int new_attr = pic30_attribute_map(sec);
      if ((pic30_debug) && ( new_attr != old_attr))
        printf("    %s attributes changed from %x to %x\n",
               sec->name, old_attr, new_attr);
    }

    /* below this point we are processing relocs only */
    if (sec->reloc_count == 0)
      continue;

    rels = bfd_pic30_load_relocs(abfd, sec, symbols);
    if (!rels)
      continue;

    /* loop through the relocs in this section */
    for (p = rels; relcount && *p != (arelent *) NULL; p++, relcount--)
    {
        arelent *q = *p;
	asymbol *psym;

        /* get the target symbol */
        psym = *q->sym_ptr_ptr;  /* note: we diverge from COFF here */
        if (q->sym_ptr_ptr && *q->sym_ptr_ptr)
           sym_name = (*(q->sym_ptr_ptr))->name;
        else
          sym_name = NULL;

        /* process memory region relocs..
           note this is non-standard use of a section list */
        if (is_memory_region) {
          pic30_append_section_to_list (user_memory_sections,
                                       (lang_input_statement_type *) region_name,
                                       (asection *) sym_name);
          continue;
        }
        
        /* process handle relocs */
        if ((q->howto->type == R_PIC30_WORD_HANDLE) ||
            (q->howto->type == R_PIC30_P_HANDLE) ||
            (q->howto->type == R_PIC30_HANDLE))
        {
#if 0
            DUMP_CANON_RELOC(q->howto->name, q);
#endif
            if (!pic30_handles)
	      break;

            /* print file heading once */
            if ((pic30_debug) && !file_printed)
            {
                printf("%s:\n", abfd->filename);
                file_printed++;
            }

            /* make sure handle hash table is ready */
            if (!handles)
              handles = handle_hash_init();

            if (pic30_debug)
	    {
              printf("  Handle symbol: %s %x %x %x\n",
                     psym->name,
                     psym->flags,
                     (unsigned int) psym->section,
                     (unsigned int) psym->value);
	    }
            if ((psym->flags & BSF_LOCAL) == BSF_LOCAL) 
            {
                /* if target is local symbol, make a global one */
                char * global_name;
                global_name = (char *)
		   bfd_alloc(output_bfd, (strlen(abfd->filename) +
                                          strlen(sym_name) + 2));
                if (!global_name)
                {
                    fprintf( stderr, 
                             "Link Error: "
			     "not enough memory for handle symbol\n");
                    abort();
                }
                strcpy(global_name, abfd->filename);
                strcat(global_name, ":");
                strcat(global_name, sym_name);
                /* if we haven't processed this symbol yet */
                handle = handle_hash_lookup (handles, global_name, 0, 0);
                if (!handle)
                {
                    /* export it */
                    if (pic30_debug)
                    {
                        printf ("  Handle is local symbol %s  %x\n", sym_name,
                                (unsigned int)psym->value);
                        printf ("  ..creating global symbol %s\n", global_name);
                    }
                    _bfd_generic_link_add_one_symbol (info, abfd, global_name,
                                                      psym->flags | BSF_GLOBAL,
                                                      psym->section,
                                                      psym->value,
                                                      global_name, 1, 0, 0);
                }
                sym_name = global_name;
            }
            /* add it to the handle list */
            bfd_pic30_add_handle_sym (sym_name, psym->flags | BSF_GLOBAL);
            handle_relocs++;
          }

        /* process dmaoffset relocs */
        if ((q->howto->type == R_PIC30_WORD_DMAOFFSET) ||
            (q->howto->type == R_PIC30_P_DMAOFFSET) ||
            (q->howto->type == R_PIC30_DMAOFFSET))
          {
            /* Symbol definitions are not all visible yet,
               so we'll make a note and check this later. */
            need_dma_memory = TRUE;
          }
#if 0
        /* process access relocs */
        if ((q->howto->type == R_PIC30_CALL_ACCESS) ||
            (q->howto->type == R_PIC30_PCREL_ACCESS) ||
            (q->howto->type == R_PIC30_ACCESS) ||
            (q->howto->type == R_PIC30_P_ACCESS) ||
            (q->howto->type == R_PIC30_L_ACCESS) ||
            (q->howto->type == R_PIC30_WORD_ACCESS))
          {
            /* get the target symbol */
            if (q->sym_ptr_ptr && *q->sym_ptr_ptr)
              sym_name = (*(q->sym_ptr_ptr))->name;
            else
              sym_name = NULL;

            if (pic30_debug)
              printf("  Access symbol: %s %x %x %x\n",
                     (*(q->sym_ptr_ptr))->name,
                     (*(q->sym_ptr_ptr))->flags,
                     (unsigned int) (*(q->sym_ptr_ptr))->section,
                     (unsigned int) (*(q->sym_ptr_ptr))->value);

          } /* process access relocs */
#endif
    }
    if (rels) {
      free(rels); /* free the reloc structure */
      if (link_info.hash->type == bfd_link_elf_hash_table) {
        // we have prematurely loaded the reloc table for our nefarious
        // purposes.  fool the elf slurper into thinking it can load them
        // again later
        sec->relocation = 0;
      }
    }
  }
  if (symbols) free(symbols);
  return(TRUE);
}


/*
** Emulation routine: bfd_pic30_adjust_psv_sections()
** 
** This function processes sections that will be accessed
** via the PSV window.
**
** EEDATA sections need to have the VMA address updated to
** match the characteristics of the PSV window.
**
** PSV sections (aka READONLY or constants-in-code)
** need to be checked for two things:
**
** 1. Total size cannot exceed 32K
** 2. Section must not cross a PSV page boundary. This
**    can happen if the section was explicitly mapped
**    in the linker script and was therefore located
**    by the sequential memory allocator.
**
** Create and scan an ordered list of output sections
** looking for the first PSV section that requires
** section blocking to avoid a PSV page boundary.
** If found, that section defines a threshold above
** which all loadable sections in program memory
** must be re-allocated.
**
** The re-allocation process involves three lists:
**
**  readonly_sections -- READONLY sections in order of decreasing size
**  code_sections -- All other sections in order of decreasing size
**  free_blocks -- Free memory blocks in order of increasing size
**
** During re-allocation, we must respect the memory
** alignment and blocking requirements of each section.
** As load addresses (LMAs) are changed, virtual addresses
** (VMAs) must be updated. For READONLY sections, the
** VMA is a data space address in the range 0x8000 to 0xFFFE.
*/

static void
bfd_pic30_update_psv_section_address(struct pic30_section *s)
{
  /* VMA address is a function of load address (LMA) */
  if (s->sec->user_set_vma == 0)
    s->sec->vma = PSV_BASE + (s->sec->lma & 0x7FFF);
  else
    {
      /* The user has specified a VMA section address.
      ** Compare it to the load address and issue
      ** a warning if the combination is invalid. */
      if (s->sec->vma != (PSV_BASE + (s->sec->lma & 0x7FFF)))
        einfo(_("%X: Link Error: VMA address specified for"
                " PSV section \'%s\' is not valid.\n"),
              s->sec->name);
    }
  if (pic30_debug)
    printf("  section %s vma = %lx, lma = %lx %s\n",
           s->sec->name, s->sec->vma, s->sec->lma,
           s->sec->user_set_vma ? "(fixed)" : "");
}

static void
bfd_pic30_adjust_psv_sections(void)
{
  bfd_vma next_page;
  unsigned int opb = bfd_octets_per_byte (output_bfd);
  struct lma_adjust_info info;
  lang_memory_region_type *prog;
  bfd_size_type actual_size;
  struct pic30_section *s;
  struct pic30_memory *b;
  int reallocate = 0;

  /*
  ** build an ordered list of output sections
  */
  pic30_init_section_list (&pic30_section_list);
  bfd_map_over_sections (output_bfd, &pic30_build_section_list, NULL);

  if (pic30_debug)
    printf("\nChecking PSV sections:\n");

  /* search the entire list and update EEDATA sections */
  for (s = pic30_section_list; s != NULL; s = s->next)
    if (s->sec && PIC30_IS_EEDATA_ATTR(s->sec) &&
        (s->sec->_raw_size > 0))
      bfd_pic30_update_psv_section_address(s);

  /*
  ** look for the first PSV section that needs blocking
  */
  for (s = pic30_section_list; s != NULL; s = s->next)
  {
    if (s->sec && PIC30_IS_PSV_ATTR(s->sec) &&
        (s->sec->_raw_size > 0))
    {
        /*
        ** check maximum size for PSV sections
        **
        ** Note: sec->_raw_size includes phantom bytes,
        **       divide by opb to get actual length
        */
        actual_size = s->sec->_raw_size / opb;
        if (actual_size > 0x8000)
          einfo(_("%P%X: Error: PSV section %s exceeds 32K bytes"
                  " (actual size = %u).\n"),
                  s->sec->name, actual_size);

        next_page = (s->sec->lma & ~ 0x7FFF) + 0x8000;
        if ((s->sec->lma + actual_size) > next_page)
          {
            /* section crosses PSV page boundary, must re-allocate */
            if (s->sec->user_set_vma)
              {
                /* The user has specified a starting address, possibly
                   with an OVERLAY command.  So we don't move it.*/
                einfo(_("%P: Warning: PSV section %s at 0x%v"
                        " crosses a PSVPAG boundary.\n"),
                      s->sec->name, s->sec->lma);
                break;
              }

            if (pic30_debug)
              printf("  section %s needs blocking at %lx\n",
                     s->sec->name, s->sec->lma);
            info.base = s->sec->lma;
            reallocate++;
            break;
          }
        else
          /* section is OK where it is, just update the VMA */
          bfd_pic30_update_psv_section_address(s);
    }
  }
  pic30_free_section_list(&pic30_section_list);

  /*
  ** exit if there's nothing else to do
  */
  if (!reallocate)
    return;

  /*
  ** determine the upper limit of available memory
  */
  prog = lang_memory_region_lookup ("program");
#define DEFAULT_PROG_LIMIT 0x80000
  if (prog->length == ~(bfd_size_type) 0) /* if no program region specified */
  {
      info.limit = DEFAULT_PROG_LIMIT;
      einfo(_("%P: Warning: program memory region not specified."
              " Using default upper limit of 0x%v\n"), info.limit);
  }
  else
    info.limit = prog->origin + prog->length;

  /*
  ** build a list of PSV sections above the threshold
  */
  pic30_init_section_list (&psv_sections);
  bfd_map_over_sections (output_bfd, &pic30_build_psv_section_list, &info);

  /*
  ** build a list of CODE sections above the threshold
  */
  pic30_init_section_list (&code_sections);
  bfd_map_over_sections (output_bfd, &pic30_build_code_section_list, &info);

  if (pic30_debug)
  {
      printf("\nPSV sections:\n");
      for (s = psv_sections; s != NULL; s = s->next)
        if (s->sec)
          {
            printf("  section %s %lx %lx %x %s\n",
                   s->sec->name, s->sec->lma,
                   s->sec->_raw_size/opb, s->sec->alignment_power,
                   s->sec->user_set_vma ? "(fixed)" : "");
          }
      printf("\nCODE sections:\n");
      for (s = code_sections; s != NULL; s = s->next)
      {
        if (s->sec)
        {
            printf("  section %s %lx %lx %x %s\n",
                   s->sec->name, s->sec->lma,
                   s->sec->_raw_size/opb, s->sec->alignment_power,
                   s->sec->user_set_vma ? "(fixed)" : "");
        }
      }
  }

  pic30_append_section_lists (psv_sections, code_sections);

  /*
  ** build the Freelist: free memory blocks above the threshold
  */
  pic30_init_memory_list (&free_blocks);
  pic30_add_to_memory_list (free_blocks, info.base, (info.limit - info.base));

  if (pic30_debug)
    {
      printf("\nFree memory blocks:\n");
      for (b = free_blocks; b != NULL; b = b->next)
        if (b->size)
          printf("  block %lx %lx\n", b->addr, b->size);
    }

  if (pic30_debug)
    printf("\nRe-allocating program memory range %lx to %lx\n",
           info.base, info.limit);

  /*
  ** allocate static sections
  */
  for (s = psv_sections; s != NULL; s = s->next)
  {
    if ((s->sec) && (s->sec->user_set_vma))
    {
        b = pic30_static_assign_memory (free_blocks, s->sec->_raw_size/opb,
                                        s->sec->lma);
        if (!b)
	{
          if ((s->sec->flags & SEC_NEVER_LOAD) ||
	      (command_line.check_section_addresses == FALSE))
	  {
	        /* OK, don't report as error */;
	  }
	  else
            einfo(_("%P%X: Error: Could not allocate section %s at %lx\n"),
                    s->sec->name, s->sec->lma);
	}
        else
        {
            /* add new free block(s) for any remainder space */
            if (b->offset)
              pic30_add_to_memory_list (free_blocks, b->addr, b->offset);

            if ((b->offset + s->sec->_raw_size/opb) < b->size)
              {
                bfd_vma new_addr = b->addr + b->offset + s->sec->_raw_size/opb;
                pic30_add_to_memory_list (free_blocks, new_addr,
                                       b->size - b->offset - s->sec->_raw_size/opb);
              }
            /*
	    ** remove the block we just used
	    */
            pic30_remove_from_memory_list (free_blocks, b);
        }
    }
  }
  /*
  ** allocate relocatable sections
  */
  for (s = psv_sections; s != NULL; s = s->next)
  {
    if ((s->sec) && (s->sec->user_set_vma == 0))
    {
        b = pic30_best_fit_memory (free_blocks, s->sec->_raw_size/opb,
                                   s->sec->alignment_power,
                                   TRUE);
        if (!b)
          einfo(_("%P%X: Error: Not enough contiguous memory"
                  " for section %s.\n"), s->sec->name);
        else
          {
            bfd_vma old_address = s->sec->lma;

            /* update the section header info */
            s->sec->lma = b->addr + b->offset;
            if (PIC30_IS_PSV_ATTR(s->sec))
	    {
              s->sec->vma = PSV_BASE + (s->sec->lma & 0x7FFF);
	    }
            else
	    {
              s->sec->vma = s->sec->lma;
	    }

            if (pic30_debug)
              printf("  moving section %s from %lx to %lx\n",
                     s->sec->name, old_address, s->sec->lma);

            /* add new free block(s) for any remainder space */
            if (b->offset)
              pic30_add_to_memory_list (free_blocks, b->addr, b->offset);

            if ((b->offset + s->sec->_raw_size/opb) < b->size)
              {
                bfd_vma new_addr = b->addr + b->offset + s->sec->_raw_size/opb;
                pic30_add_to_memory_list (free_blocks, new_addr,
                                       b->size - b->offset - s->sec->_raw_size/opb);
              }
            /* remove the block we just used */
            pic30_remove_from_memory_list (free_blocks, b);
          }
    }
  }
  if (pic30_debug)
  {
      printf("\nFree memory blocks:\n");
      for (b = free_blocks; b != NULL; b = b->next)
        if (b->size)
          printf("  block %lx %lx\n", b->addr, b->size);
  }

  /*
  ** this frees both A & B lists
  */
  pic30_free_section_list (&psv_sections);
  pic30_free_memory_list  (&free_blocks);

} /* static void bfd_pic30_adjust_psv_sections()*/


/*
** Emulation routine: bfd_pic30_tabulate_gaps()
** 
** - scan through all lang statements and
**    accumulate total gaps due to alignment
**    retrictions
**
** - the running total is stored in a global
**    symbol based on the section name.
*/
static void
bfd_pic30_tabulate_gaps_worker(statement)
     lang_statement_union_type *statement;
{
  if (statement->header.type == lang_padding_statement_enum)
    {
      char *name;
      struct bfd_link_hash_entry *h = (struct bfd_link_hash_entry *) NULL;
      asection *sec = statement->padding_statement.output_section;
      unsigned int size = (unsigned int) statement->padding_statement.size;
      if (pic30_debug)
        printf("  section %s, gap = %d bytes\n", sec->name, size);

      /* look up or create a symbol to accumulate gap data */
      name = xmalloc(strlen(sec->name) + strlen(GAP_ID) + 1);
      strcpy(name, sec->name);
      strcat(name, GAP_ID);

      h = bfd_link_hash_lookup (link_info.hash, name, FALSE, FALSE, TRUE);

      if (h == (struct bfd_link_hash_entry *) NULL)
        /* create one */
        _bfd_generic_link_add_one_symbol (&link_info, output_bfd, name,
                                          BSF_WEAK, bfd_abs_section_ptr,
                                          size, name, 1, 0, 0);
      else
        /* accumulate gap size */
        h->u.def.value += size;

      free(name);
    }
}


static void
bfd_pic30_tabulate_gaps()
{
  if (pic30_debug)
    printf("\nLooking for alignment gaps:\n");
  lang_for_each_statement (bfd_pic30_tabulate_gaps_worker);
}


/*
** Record the last address used in program memory
**
** - this function is called via bfd_map_over_sections()
*/
static void
record_last_program_address (abfd, sect, p)
     bfd *abfd ATTRIBUTE_UNUSED ;
     asection *sect;
     PTR p ATTRIBUTE_UNUSED;
{
  unsigned int opb = bfd_octets_per_byte (output_bfd);

  if ((PIC30_IS_CODE_ATTR(sect) || PIC30_IS_PSV_ATTR(sect)) &&
      sect->_raw_size > 0)
  {
    bfd_vma end = sect->lma + (sect->_raw_size / opb) - PROGRAM_WORD_SIZE;
    
    if ((end <= upper_limit_program) && (end > last_program_address))
      last_program_address = end;
  }      
  return;
}


/*
** Emulation routine: bfd_pic30_finish
**
** - perform any remaining tasks before emulation is completed
**  
*/
static void
bfd_pic30_finish(void)
{
  asection *sec;
  unsigned int const_psvpage = 0;
  unsigned int const_length = 0;
  unsigned int boot_const_psvpage = 0;
  unsigned int secure_const_psvpage = 0;
  unsigned int opb = bfd_octets_per_byte (output_bfd);
  struct bfd_link_hash_entry *h;
  int FLASH_mask = pic30_is_eds_machine(global_PROCESSOR) ? 0x200 : 0x000;

  const char **psname;
  const char *pic30_codesecs[] =
  {
    ".text", ".reset", ".ivt", ".aivt", 0
  };

  /* if we've encountered a fatal error, stop here */
  if (config.make_executable == FALSE)
    einfo("%P%F: Link terminated due to previous error(s).\n");
    
  /*
  ** remove output sections with size = 0
  */
  pic30_strip_sections(output_bfd);

  /*
  ** mark the (synthetic) code sections:
  ** - CODE
  ** - alignment = 2^1
  */
  for (psname = pic30_codesecs; psname[0]; ++psname)
  {
    sec = bfd_get_section_by_name(output_bfd, psname[0]);
    if (sec)
    {
      sec->flags |= SEC_CODE;
      sec->flags &= ~SEC_DATA;
      bfd_set_section_alignment(output_bfd, sec, 1);
    }
  }
  /* adjust psv sections upward, if necessary */
  bfd_pic30_adjust_psv_sections();

  /* see if section .const remains (size > 0) */
  sec = bfd_get_section_by_name(output_bfd, ".const");
  if (sec)
  {
      has_const_section = TRUE;
      const_psvpage = (sec->lma >> 15) | FLASH_mask;
      const_length  = sec->_raw_size /opb ;
  }

  /* define some constants for CodeGuard */
  sec = bfd_get_section_by_name(output_bfd, ".boot_const");
  if (sec) {
    boot_const_psvpage = (sec->lma >> 15) | FLASH_mask;
    pic30_has_managed_psv = TRUE;
  }

  sec = bfd_get_section_by_name(output_bfd, ".secure_const");
  if (sec) {
    secure_const_psvpage = (sec->lma >> 15) | FLASH_mask;
    pic30_has_managed_psv = TRUE;
  }

  /* mark _COMMENT section NEVER_LOAD, if it exists */
  sec = bfd_get_section_by_name(output_bfd, _COMMENT);
  if (sec)
    sec->flags |= SEC_NEVER_LOAD;

  /* tabulate gaps in output sections */
  bfd_pic30_tabulate_gaps();

  /* check for STACKSIZE symbol -- this is an old way to specify
     a stack, and is really not preferred */
  if ((h = bfd_pic30_is_defined_global_symbol("STACKSIZE"))) {
    if (pic30_has_stack_option && (h->u.def.value != pic30_stack_size))
      fprintf (stderr, "Warning: --stack option overrides STACKSIZE symbol\n");
    else
      pic30_stack_size = h->u.def.value;
  }

  /* if heap is required, make sure one is specified */
  if (pic30_heap_required && !heap_section_defined && !pic30_has_heap_option)
      einfo("%P%X Error: A heap is required, but has not been specified\n");
    
  /*
  ** Check for user-defined stack
  **
  ** note: two symbols( __SP_init, __SPLIM_init) must be defined
  */
  if ((h = bfd_pic30_is_defined_global_symbol("__SP_init"))) {
    user_defined_stack = TRUE;
    stack_base = h->u.def.value;
    /* if defined value is relative, add in the section base address */
    if (h->u.def.section && (h->u.def.section != bfd_abs_section_ptr))
      stack_base += h->u.def.section->vma;
  }
  if ((h = bfd_pic30_is_defined_global_symbol("__SPLIM_init"))) {
    stack_limit = h->u.def.value;
    /* if defined value is relative, add in the section base address */
    if (h->u.def.section && (h->u.def.section != bfd_abs_section_ptr))
      stack_limit += h->u.def.section->vma;
  }
  else
    user_defined_stack = FALSE;

  /* If stack was defined as a section, calculate range info */
  if (stack_section_defined) {
    asection *sec;

    for (sec = stack_bfd->sections; sec != 0; sec = sec->next)
      if (PIC30_IS_STACK_ATTR(sec)) break;

    if (sec == 0)
      einfo("%P%X Internal error: Could not find stack definition\n");
    else {
      if (pic30_debug)
        printf("\nStack is defined as input section %s,"
               " in output section %s\n",
               sec->name, sec->output_section->name);
      stack_base = sec->output_section->lma + sec->output_offset;
      stack_limit = stack_base +
                   (((sec->_raw_size / 2) - pic30_stackguard_size + 1) & ~1);
    }
  }

  /* If a stack was not defined as a section, or by symbols,
     allocate one from remaining memory */
  if (!stack_section_defined && !user_defined_stack) {

    if (pic30_debug)
      printf("\nCreating stack from remaining data memory...\n");

    allocate_default_stack();
  }

  /* Range check the stack, no matter how it was created */
  if ( (int) (stack_limit - stack_base) < (int) pic30_stack_size)
    {
      einfo("%P%X Error: Not enough memory for stack"
            " (%d bytes needed, %d bytes available)\n",
            pic30_stack_size + pic30_stackguard_size,
            (int) (stack_limit - stack_base) + pic30_stackguard_size);
    }

  /*
  ** Set heap symbols for the runtime library
  ** 
  ** Note: heaps have a section, unless the  heap size is zero.
  */
  if (!heap_section_defined) {
    heap_base = 0;
    heap_limit = 0;
  }
  else {
    asection *sec;

    for (sec = heap_bfd->sections; sec != 0; sec = sec->next)
      if (PIC30_IS_HEAP_ATTR(sec)) break;

    if (sec == 0)
      einfo("%P%X Internal error: Could not find heap definition\n");
    else if (sec->output_section == 0)
      einfo("%P%X Internal error: Heap was not allocated\n");
    else {
      if (pic30_debug)
        printf("\nHeap is defined as input section %s,"
               " in output section %s\n\n",
               sec->name, sec->output_section->name);
      heap_base = sec->output_section->lma + sec->output_offset;
      heap_limit = heap_base + sec->_raw_size / 2;
    }
  }

  if (pic30_debug)
    printf("Creating __heap = %x\n", heap_base);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd, "__heap",
                                    BSF_GLOBAL, bfd_abs_section_ptr,
                                    heap_base, "__heap", 1, 0, 0);
  if (pic30_debug)
    printf("Creating __eheap = %x\n", heap_limit);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd, "__eheap",
                                    BSF_GLOBAL, bfd_abs_section_ptr,
                                    heap_limit, "__eheap", 1, 0, 0);

  /*
  ** Set stack symbols for the runtime library
  */
  if (!user_defined_stack)
    {
      if (pic30_debug)
        printf("Creating __SP_init = %x\n", stack_base);
      _bfd_generic_link_add_one_symbol (&link_info, output_bfd, "__SP_init",
                                        BSF_GLOBAL, bfd_abs_section_ptr,
                                        stack_base, "__SP_init", 1, 0, 0);
      if (pic30_debug)
        printf("Creating __SPLIM_init = %x\n", stack_limit);
      _bfd_generic_link_add_one_symbol (&link_info, output_bfd, "__SPLIM_init",
                                        BSF_GLOBAL, bfd_abs_section_ptr,
                                        stack_limit, "__SPLIM_init", 1, 0, 0);
    }

  if (pic30_debug)
    printf("Creating __MIN_STACK_SIZE = %x\n", pic30_stack_size);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd, "__MIN_STACK_SIZE",
                                    BSF_GLOBAL, bfd_abs_section_ptr,
                                    pic30_stack_size, "__MIN_STACK_SIZE", 1, 0, 0);

  if (pic30_debug)
    printf("Creating __STACKGUARD_SIZE = %x\n", pic30_stackguard_size);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd, "__STACKGUARD_SIZE",
                                    BSF_GLOBAL, bfd_abs_section_ptr,
                               pic30_stackguard_size, "__STACKGUARD_SIZE", 1, 0, 0);

  /*
  ** Set tblpage, tbloffset symbols for data init template
  **   so the C startup module can find it.
  */
  if (pic30_data_init)
    {
      sec = init_template->output_section;  /* find the template's output sec */

      if (sec)
        {
          bfd_vma dinit_addr = sec->lma + init_template->output_offset;
          unsigned int tblpage   = dinit_addr >> 16;
          unsigned int tbloffset = dinit_addr & 0xFFFF;
          if (pic30_debug)
            printf("Creating __dinit_tblpage = %x\n", tblpage);
          _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                            "__dinit_tblpage", BSF_GLOBAL,
                                            bfd_abs_section_ptr, tblpage, 
                                            "__dinit_tblpage", 1, 0, 0);
          if (pic30_debug)
            printf("Creating __dinit_tbloffset = %x\n", tbloffset);
          _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                            "__dinit_tbloffset", BSF_GLOBAL,
                                            bfd_abs_section_ptr, tbloffset,
                                            "__dinit_tbloffset", 1, 0, 0);
        }
    }

  /*
  ** Set psvpage, length symbols for .const section
  **   so the C startup module can initialize PSV
  */
  if ((const_length == 0) && pic30_has_managed_psv)
    const_length = 2; /* force psv init in crt0 */

  if (pic30_debug)
    printf("Creating __const_psvpage = %x\n", const_psvpage);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                    "__const_psvpage", BSF_GLOBAL,
                                    bfd_abs_section_ptr, const_psvpage, 
                                    "__const_psvpage", 1, 0, 0);
  if (pic30_debug)
    printf("Creating __const_length = %x\n", const_length);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                    "__const_length", BSF_GLOBAL,
                                    bfd_abs_section_ptr, const_length,
                                    "__const_length", 1, 0, 0);

  /*
  ** Set some CodeGuard symbols
  */
  if (pic30_debug)
    printf("Creating __bootconst_psvpage = %x\n", boot_const_psvpage);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                    "__bootconst_psvpage", BSF_GLOBAL,
                                    bfd_abs_section_ptr, boot_const_psvpage, 
                                    "__bootconst_psvpage", 1, 0, 0);
  if (pic30_debug)
    printf("Creating __secureconst_psvpage = %x\n", secure_const_psvpage);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                    "__secureconst_psvpage", BSF_GLOBAL,
                                    bfd_abs_section_ptr, secure_const_psvpage, 
                                    "__secureconst_psvpage", 1, 0, 0);

  /*
  ** Set symbols for user_init functions
  */
  if (user_init_bfd) {
    asection *sec;
    bfd_vma addr;
    
    sec  = user_init_bfd->sections->output_section;
    addr = sec->lma + user_init_offset;
    
    if (pic30_debug)
      printf("Creating __has_user_init = 1\n");
    _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                      "__has_user_init", BSF_GLOBAL,
                                      bfd_abs_section_ptr, 1, 
                                      "__has_user_init", 1, 0, 0);
    if (pic30_debug)
      printf("Creating __user_init = %lx\n", addr);
    _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                      "__user_init", BSF_GLOBAL,
                                      bfd_abs_section_ptr, addr, 
                                      "__user_init", 1, 0, 0);
  }
  
  /*
  ** Set a symbol for the last address used in memory region "program"
  */
  upper_limit_program = program_end_address();

  bfd_map_over_sections(output_bfd, &record_last_program_address, NULL);
  if (pic30_debug)
    printf("Creating __PROGRAM_END = %lx\n", last_program_address);
  _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                    "__PROGRAM_END", BSF_GLOBAL,
                                    bfd_abs_section_ptr, last_program_address, 
                                    "__PROGRAM_END", 1, 0, 0);

} /* static void bfd_pic30_finish () */


#include "../bfd/pic30-reports.c"


#define LOOKUP_CG_SETTING(p, base_flags, seek_flags)  \
p = pic30_lookup_codeguard_setting(base_flags, seek_flags);

/*
** Assumes the following arrangement in flash:
**
**   boot | secure | general
**   low addr ---> high addr
**
** Note two sources of range info:
**
** 1. CodeGuard settings that have been validated, or
** 2. User-defined values from the command line.
*/
static void
set_codeguard_flash_boundaries(void)
{
  static bfd_boolean done;
  void *p;

  if (!done) {

    base_address[BOOTx][FLASHx] = program_base_address();

    LOOKUP_CG_SETTING(p,( BOOT | FLASH ), ( SMALL | MEDIUM | LARGE ));

    end_address[BOOTx][FLASHx] = p ?
      pic30_codeguard_setting_address(p) :
      base_address[BOOTx][FLASHx] + pic30_boot_flash_size - 2;

    base_address[SECUREx][FLASHx] = end_address[BOOTx][FLASHx] + 2;

    LOOKUP_CG_SETTING(p,( SECURE | FLASH ), ( SMALL | MEDIUM | LARGE ));

    end_address[SECUREx][FLASHx] = p ?
      pic30_codeguard_setting_address(p) :
      base_address[SECUREx][FLASHx] + pic30_secure_flash_size - 2;
      
    base_address[GENERALx][FLASHx] = end_address[SECUREx][FLASHx] + 2;
    end_address [GENERALx][FLASHx] = program_end_address();
    
    if (end_address [GENERALx][FLASHx] < base_address[GENERALx][FLASHx])
      einfo(_("Warning: CodeGuard settings result in a"
              " zero-length general segment (FLASH)\n"));
    done = TRUE;
  }
}

static void
dump_codeguard_flash_boundaries(FILE *f)
{
  fprintf(f,"\nCodeGuard FLASH Memory:\n");

  fprintf(f,"  boot    ");
  if (BOOT_IS_ACTIVE(FLASHx))
    fprintf(f,"0x%lx to 0x%lx\n",
         base_address[BOOTx][FLASHx], end_address[BOOTx][FLASHx]);
  else
    fprintf(f,"(none)\n");

  fprintf(f,"  secure  ");
  if (SECURE_IS_ACTIVE(FLASHx))
    fprintf(f,"0x%lx to 0x%lx\n",
         base_address[SECUREx][FLASHx], end_address[SECUREx][FLASHx]);
  else
    fprintf(f,"(none)\n");

  fprintf(f,"  general ");
  if (end_address [GENERALx][FLASHx] >= base_address[GENERALx][FLASHx])
    fprintf(f,"0x%lx to 0x%lx\n",
           base_address[GENERALx][FLASHx], end_address[GENERALx][FLASHx]);
  else
    fprintf(f,"(none)\n");
}


/*
** Assumes the following arrangement in ram:
**
**   general | secure | boot | dma
**     low addr  --->  high addr
**
** Note two sources of range info:
**
** 1. CodeGuard settings that have been validated, or
** 2. User-defined values from the command line.
*/
static void
set_codeguard_ram_boundaries(void)
{
  static bfd_boolean done;
  bfd_vma upper_limit;
  bfd_boolean boot_seg, secure_seg;
  void *p,*s;

  if (!done) {

    LOOKUP_CG_SETTING(p,( BOOT | RAM ), ( SMALL | MEDIUM | LARGE ));
    boot_seg   = p || pic30_boot_ram_size;

    LOOKUP_CG_SETTING(s,( SECURE | RAM ), ( SMALL | MEDIUM | LARGE ));
    secure_seg = s || pic30_secure_ram_size;

    if ((boot_seg | secure_seg) &&
        global_PROCESSOR && 
        pic30_is_dma_machine(global_PROCESSOR)) {

      /* we need a definition for __DMA_BASE */
      if (!early_assignment(&dma_base, "__DMA_BASE"))
        einfo(_(str1), str3);

      upper_limit = dma_base - 1;
    }
    else
      upper_limit = data_end_address();

    base_address[BOOTx][RAMx] = p ?
      pic30_codeguard_setting_address(p) :     /* source 1 */
      upper_limit - pic30_boot_ram_size + 1;   /* source 2 */
    end_address[BOOTx][RAMx] = upper_limit;

    base_address[SECUREx][RAMx] = s ?
      pic30_codeguard_setting_address(s) :                  /* source 1 */
      base_address[BOOTx][RAMx]  - pic30_secure_ram_size;   /* source 2 */
    end_address[SECUREx][RAMx] = base_address[BOOTx][RAMx] - 1;

    base_address[GENERALx][RAMx] = data_base_address();
    end_address [GENERALx][RAMx] = base_address[SECUREx][RAMx] - 1;

    if (end_address [GENERALx][RAMx] < base_address[GENERALx][RAMx])
      einfo(_("Warning: CodeGuard settings result in a"
              " zero-length general segment (RAM)\n"));
    done = TRUE;
  }
}

static void
dump_codeguard_ram_boundaries(FILE *f)
{
  fprintf(f,"\nCodeGuard RAM Memory:\n");
  fprintf(f,"  general ");
  if (end_address[GENERALx][RAMx] >= base_address[GENERALx][RAMx])
    fprintf(f,"0x%lx to 0x%lx\n",
            base_address[GENERALx][RAMx], end_address[GENERALx][RAMx]);
  else
    fprintf(f,"(none)\n");

  fprintf(f,"  secure  ");
  if (SECURE_IS_ACTIVE(RAMx))
    fprintf(f,"0x%lx to 0x%lx\n",
         base_address[SECUREx][RAMx], end_address[SECUREx][RAMx]);
  else
    fprintf(f,"(none)\n");

  fprintf(f,"  boot    ");
  if (BOOT_IS_ACTIVE(RAMx))
    fprintf(f,"0x%lx to 0x%lx\n",
         base_address[BOOTx][RAMx], end_address[BOOTx][RAMx]);
  else
    fprintf(f,"(none)\n");
}


/*
** Assumes the following arrangement in eedata:
**
**   general | secure | boot
**   low addr ---> high addr
*/
static void
set_codeguard_eeprom_boundaries(void)
{
  static bfd_boolean done;
  void *p;

  if (!done) {

    LOOKUP_CG_SETTING(p,( BOOT | EEPROM ), ( SMALL | MEDIUM | LARGE ));

    base_address[BOOTx][EEPROMx] = p ?
      pic30_codeguard_setting_address(p) : eedata_end_address() + 2;
    end_address[BOOTx][EEPROMx] = eedata_end_address();

    LOOKUP_CG_SETTING(p,( SECURE | EEPROM ), ( SMALL | MEDIUM | LARGE ));

    base_address[SECUREx][EEPROMx] = p ?
      pic30_codeguard_setting_address(p) : base_address[BOOTx][EEPROMx];
    end_address[SECUREx][EEPROMx] = base_address[BOOTx][EEPROMx] - 2;

    base_address[GENERALx][EEPROMx] = eedata_base_address();
    end_address [GENERALx][EEPROMx] = base_address[SECUREx][EEPROMx] - 1;
    done = TRUE;
  }
}

static void
dump_codeguard_eeprom_boundaries(FILE *f)
{
  fprintf(f,"\nCodeGuard EEPROM Memory:\n");
  fprintf(f,"  general 0x%lx to 0x%lx\n",
         base_address[GENERALx][EEPROMx], end_address[GENERALx][EEPROMx]);

  fprintf(f,"  secure  ");
  if (SECURE_IS_ACTIVE(EEPROMx))
    fprintf(f,"0x%lx to 0x%lx\n",
         base_address[SECUREx][EEPROMx], end_address[SECUREx][EEPROMx]);
  else
    fprintf(f,"(none)\n");

  fprintf(f,"  boot    ");
  if (BOOT_IS_ACTIVE(EEPROMx))
    fprintf(f,"0x%lx to 0x%lx\n",
         base_address[BOOTx][EEPROMx], end_address[BOOTx][EEPROMx]);
  else
    fprintf(f,"(none)\n");
}

static void
dump_user_defined_codeguard_segments(FILE *f)
{
  fprintf(f,"\nUser-Defined CodeGuard Segments\n");
  if (pic30_boot_flash_size)
    fprintf(f,"  boot FLASH:   %#9x units\n", pic30_boot_flash_size);
  if (pic30_secure_flash_size)
    fprintf(f,"  secure FLASH: %#9x units\n", pic30_secure_flash_size);
  if (pic30_boot_ram_size)
    fprintf(f,"  boot RAM:     %#9x bytes\n", pic30_boot_ram_size);
  if (pic30_secure_ram_size)
    fprintf(f,"  secure RAM:   %#9x bytes\n", pic30_secure_ram_size);
}

static int
is_valid_config_word_section_name(const char *secname)
{
  int i = 0;
  while (valid_cg_section_names[i]) {  /* null terminated list */
    if (strcmp(secname, valid_cg_section_names[i++]) == 0)
      return 1;
  }
  return 0;
}

/*
** Extract aaa from a string like __aaa.*
*/
static char *
config_word_name(const char *secname)
{
  char *p,*p2;

  if ((secname[0] != '_') && (secname[1] != '_'))
    return (char *) secname;

  p = xmalloc(strlen(secname)+1);
  p = strcpy(p, secname+2);
  p2 = strstr(p, ".");
  if (p2) p2[0] = 0;

  return p;
}


/*****************************************************************************/

/*
** Entry points in the emulation transfer structure
*/


/*
** before_parse() is called before options are parsed.
*/
static void
gld${EMULATION_NAME}_before_parse()
{
#ifndef TARGET_			/* I.e., if not generic.  */
  ldfile_set_output_arch ("`echo ${ARCH}`");
#endif /* not TARGET_ */
  bfd_pic30_before_parse();
}


/*
** after_parse() is called after the linker script is read.
*/
static void
gld${EMULATION_NAME}_after_parse()
{
  bfd_pic30_after_parse();
}


/*
** set_output_arch() is called after options have been parsed
**  and before input files are opened
*/
static void
gld${EMULATION_NAME}_set_output_arch()
{
  /* standard GNU */
  bfd_set_arch_mach (output_bfd,
                     ldfile_output_architecture, ldfile_output_machine);
  /* C30-specific */
  pic30_output_bfd = output_bfd;  /* save a copy for bfd to see */
  if (pic30_has_processor_option == 0)
    global_PROCESSOR = pic30_get_machine(ldfile_output_machine_name);
  else if ((global_PROCESSOR->mach != ldfile_output_machine) &&
           (ldfile_output_machine != 0))
    einfo(_("%P: Warning: target processor '%s' does not match"
            " linker script\n"), global_PROCESSOR->printable_name);
}


#if (defined(C30_SMARTIO_RULES) && (C30_SMARTIO_RULES > 1))
/* match against pic30_smartio_symbol, sorry for the global variable :( */
char *pic30_smartio_symbol;

struct smartio_sym_list {
  struct bfd_link_hash_entry *h;
  unsigned long long cum_mask;
  struct smartio_sym_list *next;
} *smartio_fn_list, *smartio_free_list;

static bfd_boolean
pic30_smartio_fn_list(struct bfd_link_hash_entry *h, PTR p) {
  struct smartio_sym_list *l;

  if (strncmp(pic30_smartio_symbol, h->root.string,
              strlen(pic30_smartio_symbol)) == 0) {
    unsigned long long mask = 0;
    int bit;
    char *c;

    // bfd_vma value = LINK_HASH_VALUE(h);
    for (c = &h->root.string[strlen(pic30_smartio_symbol)]; *c; c++) {
      if (*c == '_') continue;
      if (*c == '0') bit = 0; 
      else {
        bit = *c - 'A' + 1;
        if (bit > 26) bit = 27 + (*c - 'a');
      }
      mask |= (1ULL << bit);
    }
    if (smartio_free_list) {
      l = smartio_free_list;
      smartio_free_list = l->next;
    } else {
      l = xmalloc(sizeof(struct smartio_sym_list));
    }
    l->h = h;
    if (smartio_fn_list)  mask |= smartio_fn_list->cum_mask;
    l->cum_mask = mask;
    l->next = smartio_fn_list;
    smartio_fn_list = l;
  }
  return TRUE;  /* continue */
}

/* search the function pair type information and track special symbols -
   keep those symbols that match, noting the variant and object file name
   so that we can later force their removal

   a NULL module_name implies that we are just checking, and we should return
   trueness */

unsigned
force_keep_symbol(char *symbol, char *module_name) {
  struct function_pair_type *fp;
  struct reduced_set_list *rsl = 0;

  for (fp = function_pairs; fp->full_set; fp++) {
    if (strncmp(fp->prefix, symbol, strlen(fp->prefix)) == 0) {
      if (module_name == 0) return 1;
      /* boing */
      for (rsl = fp->rsl; rsl; rsl = rsl->next) {
        /* reduced set already noted, so return true */
        if (strcmp(rsl->reduced_set, symbol) == 0) return 1;
      }
      rsl = xmalloc(sizeof(struct reduced_set_list));
      rsl->reduced_set = symbol;
      rsl->module_name = module_name;
      rsl->next = fp->rsl;
      fp->rsl = rsl;
      return 1;
    }
  }
  return 0;
}

static void
pic30_release_kept_symbols(char *symbol) {
  struct function_pair_type *fp;
  struct reduced_set_list *rsl = 0, *next;

  for (fp = function_pairs; fp->full_set; fp++) {
    if (strncmp(fp->prefix, symbol, strlen(fp->prefix)) == 0) {
      for (rsl = fp->rsl; rsl; rsl = next) {
        next = rsl->next;
        if (strcmp(&symbol[strlen(symbol)-2],"_s") == 0) {
          /* _0 suffix == _s suffix, then don't remove the module because the
              symbols are defined in the same object file */
          if (strcmp(&rsl->reduced_set[strlen(rsl->reduced_set)-2],"_0") == 0) {
            if (pic30_debug) 
              fprintf(stderr,"*** Not removing %s\n", rsl->module_name);
            continue;
          }
        }
        if (strcmp(rsl->reduced_set, symbol) != 0) {
          /* this symbol was not used, so release it */
          bfd_pic30_remove_archive_module(rsl->module_name);
        }
        free(rsl);
      }
      fp->rsl = 0;
    }
  }
}

static void
smartio_symbols(struct bfd_link_info *info) {
  int i = 0;
  struct bfd_link_hash_entry *undefs = 0;
  struct bfd_link_hash_entry *newundefs = 0;
  struct bfd_link_hash_entry *last = 0;

  /* format different for new rules - look for letter combinations
     for each function and choose the best match */
  while ( function_pairs[i].full_set )
    {  struct smartio_sym_list *l;
       struct bfd_link_hash_entry *u = 0;
       struct bfd_link_hash_entry *full;

       char suffix[] = "_aAcdeEfFgGnopsuxX";

       if (info) {
         undefs=info->hash->undefs;
         if (undefs == 0) return;
       }
       pic30_smartio_symbol = function_pairs[i].prefix;
       if (undefs) {
         /* gather all the stats on undefined functions */
         for (u = undefs; u; u = u->next) {
           pic30_smartio_fn_list(u,0);
         }
       } else {
         bfd_link_hash_traverse(link_info.hash, pic30_smartio_fn_list,
                                  0 /* not used */);
       }
       if (smartio_fn_list) {
         int letter;
         int s = 1;
         char buffer_map_to[256];

         if (smartio_fn_list->cum_mask > 1) {
           /* this means that we have an accumulated suffix that includes
              more than just '0' [the wild-card-suffix] */
           for (letter = 0; letter < 26; letter++) {
             if (smartio_fn_list->cum_mask & (1ULL << letter+27))
               suffix[s++] = 'a' + letter;
             if (smartio_fn_list->cum_mask & (1ULL << letter+1))
               suffix[s++] = 'A' + letter;
           }
           suffix[s] = 0;
         } else {
           sprintf(suffix, "_0");
         }
         sprintf(buffer_map_to, "%s%s", function_pairs[i].prefix,
                 suffix);
         if (undefs) {
           /* in this mode we are adding undefined symbols to the end of
              the list so that the regular mechanism can pull them in */
           if (bfd_hash_lookup(info->hash, buffer_map_to, 0, 0) == 0) {
             struct bfd_link_hash_entry *new;

             if (pic30_debug) {
               fprintf(stderr,"Adding %s to undef\n", buffer_map_to);
               for (l = smartio_fn_list; l; l=l->next)
                 fprintf(stderr,"  because of: %s\n", l->h->root.string);
             }
             new = bfd_hash_lookup(info->hash, buffer_map_to, 1, 1);
             new->next = newundefs;
             newundefs=new;
             if (last == 0) last = new;
           }
         } else {
           full = bfd_pic30_is_defined_global_symbol(buffer_map_to);
           if (!full) {
             if (pic30_debug)
               fprintf(stderr," no hash for %s\n", buffer_map_to);
           } else {
             for (l = smartio_fn_list; l; l=l->next) {
               if (pic30_debug)
                 printf("\nMapping %s to %s\n", l->h->root.string,
                                                buffer_map_to);
               l->h->u.def.value = full->u.def.value;
               l->h->u.def.section = full->u.def.section;
             }
             pic30_release_kept_symbols(buffer_map_to);
           }
         }
         /* free the list */
         if (!smartio_free_list) {
           for (l = smartio_fn_list; l->next; l = l->next);
           l->next = smartio_free_list;
         }
         smartio_free_list = smartio_fn_list;
         smartio_fn_list = 0;
       }
       i++;
    }
  if (newundefs) {
    if (info->hash->undefs_tail)
      info->hash->undefs_tail->next = newundefs;
    else info->hash->undefs = newundefs;
    info->hash->undefs_tail = last;
  }
}

unsigned int (*pic30_force_keep_symbol)(char *, char *) = force_keep_symbol;
void (*pic30_smartio_symbols)(struct bfd_link_info *) = smartio_symbols;
#endif

#if 1
void pic30_create_data_init_template(void) {
  struct pic30_section *s;
  int total_data = 0;
  asection *sec;
  /*
  ** If data init support is enabled, create a BFD
  ** for section .dinit and add it to the link.
  */
  if (pic30_data_init)
    {
      init_bfd = bfd_pic30_create_data_init_bfd (output_bfd);
      bfd_pic30_add_bfd_to_link (init_bfd, init_bfd->filename);

       /* Compute size of data init template */
      for (s = data_sections; s != NULL; s = s->next)
        if ((s->sec) && ((s->sec->flags & SEC_EXCLUDE) == 0))
          bfd_pic30_scan_data_section(s->sec, &total_data);

      total_data += 4; /* zero terminated */

      if (pic30_debug)
        {
          printf("  null terminator, template += 1 pword\n");
          printf("\nTotal initialized data %s: %x pwords\n",
                 pic30_pack_data ? "(packed)" : "(not packed)",
                 total_data / 4);
        }

      /* allocate memory for the template */
      init_data = (unsigned char *) bfd_alloc (output_bfd, total_data);
      if (!init_data)
        {
          fprintf( stderr, "Link Error: not enough memory for data template\n");
          abort();
        }

      /* fill the template with a default value */
      init_data = memset( init_data, 0x11, total_data);

      /* attach it to the input section */
      sec = bfd_get_section_by_name(init_bfd, ".dinit");
      if (sec)
        {
          sec->_raw_size = total_data;
          sec->flags |= (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LOAD | SEC_CODE | SEC_KEEP);
          sec->contents = init_data;
          bfd_set_section_size (init_bfd, sec, total_data);
          init_template = sec;  /* save a copy for later */
        }
      else
        if (pic30_debug)
          printf("after_open: section .dinit not found\n");

    } /* if (pic30_data_init) */
  else
    {
      /* warn if initial data values will be ignored */
      for (s = data_sections; s != NULL; s = s->next)
        if (s->sec)
          bfd_pic30_skip_data_section(s->sec, &total_data);
    }
#endif
}


/*
** after_open() is called after all input BFDS
** have been created.
**
** Merge full- and reduced-set I/O functions.
**
** Create the handle jump table.
**
** Scan the input sections and create a list of
** DATA or BSS type sections.
**
** If --data-init is enabled, allocate storage for
** the template and attach it to input section .dinit,
** otherwise issue a warning for initial data values
** that are ignored.
**
** Select a __reset function.
**
** Create a default interrupt handler, if neccesary.
**
** Create a user_init function terminator, if neccesary.
**
** Create a heap, if necessary.
**
** Validate CodeGuard options, if present.
**
** Encode the CodeGuard security model.
**
** Create access entry tables for CodeGuard.
**
*/
static void
gld${EMULATION_NAME}_after_open()
{
  cg_option_list_type *lst;
  struct pic30_section *s;
  int total_data = 0;
  asection *sec;

  /*
  ** SSR# 26079: If ICD2 option has been selected,
  ** set the global symbol now, to work around a
  ** command line order dependancy in binutils 2.14
  */
  if (pic30_has_icd2_option)
    _bfd_generic_link_add_one_symbol (&link_info, output_bfd, icd2ram,
                                      BSF_GLOBAL, bfd_abs_section_ptr,
                                      1, icd2ram, 1, 0, 0);

  /*
  ** Load the set of valid CodeGuard options, based on device
  */
  if (global_PROCESSOR)
    pic30_load_codeguard_settings(global_PROCESSOR, pic30_debug);


  /*
  ** Validate CodeGuard settings in object code, if present.
  */
  if (pic30_debug)
    printf("\nLooking for CodeGuard settings in object code:\n");

  {
    LANG_FOR_EACH_INPUT_STATEMENT (is) {

      for (sec = (is)->the_bfd->sections; sec != 0; sec = sec->next) {

        if (sec && is_valid_config_word_section_name(sec->name)) {
          unsigned short val;

          if (!bfd_get_section_contents((is)->the_bfd, sec, &val, 0, 2))
            einfo(_("%P%F: Could not read data from section \'%s\'" ),
                  sec->name);

          if (pic30_debug)
          printf("  input file %s, %s, value = 0x%x\n",
                 is->filename, sec->name, val);

          /*
          ** Decode a config word
          **
          ** Several settings may be encoded in each config word;
          ** the called function in bfd/cpu-pic30.c builds
          ** a list. If no valid settings are found,
          ** report an error.
          */
          if (!pic30_decode_CG_settings(config_word_name(sec->name),
                                        val, pic30_debug))
            einfo(_("%P%F: Error: Settings in \'%s\' are not valid"
                    " for target device %s\n" ),
                  sec->name, global_PROCESSOR ?
                  global_PROCESSOR->printable_name : "" );

          /* zero out the section size, we'll create a new one later */
          bfd_set_section_size ((is)->the_bfd, sec, 0);
        }
      }
    }
  }


  /*
  ** Validate CodeGuard options from the command line, if present.
  */
  if (pic30_has_boot_option ||
      pic30_has_secure_option ||
      pic30_has_general_option) {

    if (pic30_debug)
      printf("\nCodeGuard options specified on command line:\n");

    /* validate user-specified options */
    for (lst = pic30_cg_options; lst != NULL; lst = lst->next) {
      void *s;

      if (lst->opt == NULL) continue;

      s = pic30_lookup_valid_codeguard_setting(lst->opt->flag_val);
      if (s == NULL)
        einfo("%P%F: Error: %s option \'%s\' is not supported on target device %s\n",
              (lst->opt->flag_val & BOOT) ? "boot" :
              (lst->opt->flag_val & SECURE) ? "secure" :
              (lst->opt->flag_val & GENERAL) ? "general" :
              "CodeGuard",
              lst->opt->name, global_PROCESSOR ? 
              global_PROCESSOR->printable_name : "" );
      else {
        if (pic30_debug)
          printf("  %s\n", pic30_codeguard_setting_name(s));

        if (!pic30_add_selected_codeguard_option(s))
          einfo("%P%F: Error: CodeGuard options conflict\n");
      }
    }
  }

  if (pic30_debug && (pic30_has_user_boot || pic30_has_user_secure))
    dump_user_defined_codeguard_segments(stdout);

  if (pic30_debug)
    pic30_dump_selected_codeguard_options(stdout);


  /*
  ** Encode CodeGuard settings
  */
  {
    unsigned short val;
    bfd *abfd;
    char *p,*lst = pic30_unique_selected_configword_names();

    p = strtok(lst, ",");
    while (p) {
      val = pic30_encode_CG_settings(p);
      abfd = bfd_pic30_create_config_word_bfd(p, val);
      if (pic30_debug)
        printf("  %s: 0x%x\n", p, val);
      bfd_pic30_add_bfd_to_link (abfd, abfd->filename);
      p = strtok(0, ",");
    }
  }
  
  /*
  ** Calculate CodeGuard memory boundaries
  */
  set_codeguard_flash_boundaries();
  set_codeguard_ram_boundaries();
  if (global_PROCESSOR && 
      pic30_is_eedata_machine(global_PROCESSOR))
    set_codeguard_eeprom_boundaries();
    

  if (pic30_debug) {
    dump_codeguard_flash_boundaries(stdout);
    dump_codeguard_ram_boundaries(stdout);
    if (global_PROCESSOR && 
        pic30_is_eedata_machine(global_PROCESSOR))
      dump_codeguard_eeprom_boundaries(stdout);
  }


  /*
  ** Merge full- and reduced-set I/O functions
  */
  if (pic30_smart_io)
    {
      int i = 0;

      if (pic30_debug)
        printf("\nMerging smart-io functions:\n");

#if (defined(C30_SMARTIO_RULES) && (C30_SMARTIO_RULES > 1))
      pic30_smartio_symbols(0);
#else
      while ( function_pairs[i].full_set )

        {
          struct bfd_link_hash_entry *full, *reduced;
          char *func1, *func2;

          func1 = function_pairs[i].full_set;
          func2 = function_pairs[i].reduced_set;
          if (pic30_debug)
            printf("\nLooking for (%s, %s) ...", func1, func2);

          if ((full = bfd_pic30_is_defined_global_symbol (func1)) &&
              (reduced = bfd_pic30_is_defined_global_symbol (func2)))
            {
              if (pic30_debug)
                printf("Found\n\nRedirecting %s -> %s\n", func2, func1);

              /* redirect reduced_set function to full_set function */
              reduced->u.def.value = full->u.def.value;
              reduced->u.def.section = full->u.def.section;

              /* remove the reduced_set module */
              bfd_pic30_remove_archive_module (function_pairs[i].module_name);
            }
          else
            if (pic30_debug)
              printf("Not Found\n");
          i++;
        }
#endif
    }

  /* prepare a list for sections in user-defined regions */
  if (user_memory_sections)
    pic30_free_section_list(&user_memory_sections);
  pic30_init_section_list(&user_memory_sections);

  if (pic30_debug)
    printf("\nLooping through the input bfds:\n");
  {
    /* loop through all of the input bfds */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
        if (!bfd_pic30_process_bfd_after_open(is->the_bfd, &link_info))
          {
            einfo("Errors encountered processing file %s\n", is->filename);
          }
      }
  }
  /* OK, we've seen them all... now create the jump table */
  if (handle_relocs)
    {
      if (pic30_debug)
        { 
        printf("\nTotal Handle Relocations: %lu\n",handle_relocs);
        printf("Total Unique Handles: %u\n",handles->num);
        printf("Output BFD: %s\n",output_bfd->filename);
        }
      handle_bfd = bfd_pic30_create_jump_table_bfd (output_bfd);
      bfd_pic30_add_bfd_to_link (handle_bfd, handle_bfd->filename);
    }

  /* post-process CodeGuard access entries */
  if (has_boot_access || has_secure_access)
    {
      bfd *abfd;

      if (pic30_debug) {
        int i;
        printf("\nDefined access entries\n  boot:");
        for (i=0; i<NUM_BOOT_ACCESS_SLOTS; i++)
          if (boot_access[i] != 0) printf(" %d", i+1);
        printf("\n  secure:");
        for (i=0; i<NUM_SECURE_ACCESS_SLOTS; i++)
          if (secure_access[i] != 0) printf(" %d", i+1);
        printf("\n");
      }

      /* create the boot access table */
      if (has_boot_access) {
        abfd = bfd_pic30_create_branch_table_bfd(".boot",
                                                 base_address[BOOTx][FLASHx],
                                                 NUM_BOOT_ACCESS_SLOTS,
                                                 boot_access, output_bfd,
                                                 boot_unused_entry_defined,
                                                 boot_isr_entry_defined);
        bfd_pic30_add_bfd_to_link (abfd, abfd->filename);
      }

      /* create the secure access table */
      if (has_secure_access) {
        abfd = bfd_pic30_create_branch_table_bfd(".secure",
                                                 base_address[SECUREx][FLASHx],
                                                 NUM_SECURE_ACCESS_SLOTS,
                                                 secure_access, output_bfd,
                                                 secure_unused_entry_defined,
                                                 secure_isr_entry_defined);
        bfd_pic30_add_bfd_to_link (abfd, abfd->filename);
      }

    }

  /* init list of input data sections */
  pic30_init_section_list(&data_sections);

  /*
   * Loop through all input sections and
   * build a list of DATA or BSS type.
   */
  {
    LANG_FOR_EACH_INPUT_STATEMENT (f)
      {
        for (sec = f->the_bfd->sections;
             sec != (asection *) NULL;
             sec = sec->next)
          if ((sec->_raw_size > 0) &&
              (PIC30_IS_BSS_ATTR(sec) || PIC30_IS_DATA_ATTR(sec)))
            pic30_append_section_to_list(data_sections, f, sec);
      }
  }

#if 0
  /*
  ** If data init support is enabled, create a BFD
  ** for section .dinit and add it to the link.
  */
  if (pic30_data_init)
    {
      init_bfd = bfd_pic30_create_data_init_bfd (output_bfd);
      bfd_pic30_add_bfd_to_link (init_bfd, init_bfd->filename);

       /* Compute size of data init template */
      for (s = data_sections; s != NULL; s = s->next)
        if (s->sec)
          bfd_pic30_scan_data_section(s->sec, &total_data);

      total_data += 4; /* zero terminated */

      if (pic30_debug)
        {
          printf("  null terminator, template += 1 pword\n");
          printf("\nTotal initialized data %s: %x pwords\n",
                 pic30_pack_data ? "(packed)" : "(not packed)",
                 total_data / 4);
        }

      /* allocate memory for the template */
      init_data = (unsigned char *) bfd_alloc (output_bfd, total_data);
      if (!init_data)
        {
          fprintf( stderr, "Link Error: not enough memory for data template\n");
          abort();
        }

      /* fill the template with a default value */
      init_data = memset( init_data, 0x11, total_data);

      /* attach it to the input section */
      sec = bfd_get_section_by_name(init_bfd, ".dinit");
      if (sec)
        {
          sec->_raw_size = total_data;
          sec->flags |= (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LOAD | SEC_CODE | SEC_KEEP);
          sec->contents = init_data;
          bfd_set_section_size (init_bfd, sec, total_data);
          init_template = sec;  /* save a copy for later */
        }
      else
        if (pic30_debug)
          printf("after_open: section .dinit not found\n");

    } /* if (pic30_data_init) */
  else
    {
      /* warn if initial data values will be ignored */
      for (s = data_sections; s != NULL; s = s->next)
        if (s->sec)
          bfd_pic30_skip_data_section(s->sec, &total_data);
    }
#endif


 /*
  ** Look for a user-defined __reset function.
  **
  ** If we find one, remove any that were loaded
  ** from archives.
  **
  ** Note: A user-defined __reset must be strongly defined.
  ** The archive versions must be weakly defined.
  */
  {
    struct bfd_link_hash_entry *h;
    if ((h = bfd_pic30_is_defined_global_symbol("__reset"))) /* implies strong */
      {
        if (pic30_debug)
            printf("\nFound a user-defined startup module\n");
        if (pic30_startup0_file)
          bfd_pic30_remove_archive_module (pic30_startup0_file);
        if (pic30_startup1_file)
          bfd_pic30_remove_archive_module (pic30_startup1_file);
        pic30_has_user_startup = 1;
      }
  }

  /* If the user has not provided a __reset function,
  ** keep one of the standard modules, and discard the other.
  */
  if (pic30_has_user_startup == 0)
    {
      if (pic30_data_init)
        {
          /* 
          ** Set the definition of global symbol __reset to the
          ** primary startup module and discard the alternate module.
          */
          struct bfd_link_hash_entry *h;

          if (pic30_debug)
            printf("\nLooking for primary startup module..");

          if ((h = bfd_pic30_is_defined_global_symbol("__resetPRI")))
            {
              if (pic30_debug)
                printf("OK\n");
              bfd_pic30_redefine_global_symbol ("__reset",
                                                h->u.def.section, h->u.def.value);
            }
          else
            {
              if (pic30_debug)
                printf("not found\n");
            }

          if (pic30_startup1_file)
            bfd_pic30_remove_archive_module (pic30_startup1_file);
        } /* if (pic30_data_init) */
      else
        {
          /* 
          ** Set the definition of global symbol __reset to the
          ** alternate startup module and discard the primary module.
          */
          struct bfd_link_hash_entry *h;

          if (pic30_debug)
              printf("\nLooking for alternate startup module..");

          if ((h = bfd_pic30_is_defined_global_symbol("__resetALT")))
            {
              if (pic30_debug)
                printf("OK\n");
              bfd_pic30_redefine_global_symbol ("__reset",
                                                h->u.def.section, h->u.def.value);
            }
          else
            {
              if (pic30_debug)
                printf("not found\n");
            }
          if (pic30_startup0_file)
            bfd_pic30_remove_archive_module (pic30_startup0_file);
        } /* else (!pic30_data_init) */
    } /* if (pic30_has_user_startup == 0) */

  /*
  ** Look for a user-defined __DefaultInterrupt function.
  **
  ** If we don't find one, create it now, unless
  ** the user has suppressed it with --no-isr.
  */
  {
    struct bfd_link_hash_entry *h;
    if ((h = bfd_pic30_is_defined_global_symbol("__DefaultInterrupt")))
      {
        if (pic30_debug)
            printf("\nFound a user-defined default interrupt handler\n");
        pic30_has_user_default_interrupt = 1;
      }
    else if (pic30_isr)
      {
        if (pic30_debug)
          printf("\nCreating __DefaultInterrupt function\n");
        isr_bfd = bfd_pic30_create_default_isr_bfd (output_bfd);
        bfd_pic30_add_bfd_to_link (isr_bfd, isr_bfd->filename);
      }
    else
      {
        if (pic30_debug)
          printf("\nSetting __DefaultInterrupt to 0\n");
        _bfd_generic_link_add_one_symbol (&link_info, output_bfd,
                                          "__DefaultInterrupt", BSF_GLOBAL,
                                          bfd_abs_section_ptr, 0, 
                                          "__DefaultInterrupt", 1, 0, 0);
      }
  }

  /*
  ** If user_init functions are present, create a terminator.
  **
  ** It will automatically be added to the end, whether
  ** the sections are explicitly mapped or not.
  */
  if (has_user_init_functions) {
    if (pic30_debug)
      printf("\nCreating user_init function terminator\n");
    user_init_bfd = bfd_pic30_create_user_init_bfd (output_bfd);
    bfd_pic30_add_bfd_to_link (user_init_bfd, user_init_bfd->filename);
  }

  /*
  ** If a heap is required, but not provided
  ** as an input section, create one.
  **
  ** FIXME: may want to test pic30_heap_required
  ** and create a default size heap 
  */
  if (!heap_section_defined && (pic30_heap_size > 0)) {
    if (pic30_debug)
      printf("\nCreating heap of size %x\n", pic30_heap_size);
    heap_bfd = bfd_pic30_create_heap_bfd (output_bfd);
    bfd_pic30_add_bfd_to_link (heap_bfd, heap_bfd->filename);
    heap_section_defined = TRUE;
  }

}/* static void gld${EMULATION_NAME}_after_open ()*/


void
pic30_set_output_section_flags(lang_output_section_statement_type *os)
{
  /* If a section is empty or length zero, skip it */
  if ((os->bfd_section == 0) ||
      (os->bfd_section->_raw_size == 0))
    return;

   /* If a section is named _COMMENT, skip it */
  if (strcmp(os->bfd_section->name, _COMMENT) == 0)
    return;

  /*
  ** A section with no flags (but non-zero length)
  ** must have been created by a dot expression
  ** in the linker script. Mark it SEC_ALLOC
  ** to show that it occupies space in memory.
  ** It will be considered a bss-type section.
  */
  if (os->bfd_section->flags == 0)
    {
      os->bfd_section->flags |= SEC_ALLOC;
      if (pic30_debug)
        printf("  setting SEC_ALLOC for section %s\n",
               os->bfd_section->name);
    }

  /*
  ** If section has LOADable contents, one of DATA,
  ** CODE, PSV, READONLY, or EEDATA should be specified.
  ** If not, mark as DATA or CODE, depending
  ** on the memory region name.
  */
  if ((os->bfd_section->flags & (SEC_LOAD)) &&
    ((os->bfd_section->flags &
        (SEC_DATA | SEC_CODE | SEC_READONLY)) == 0) &&
      (os->bfd_section->psv == 0) &&
      (os->bfd_section->eedata == 0))
    {
      if (strstr(os->region->name, "data") ||
          (os->lma_region && strstr(os->lma_region->name, "data")))
        {
          /* region "*data*" is marked SEC_DATA */
          os->bfd_section->flags |= SEC_DATA;
         if (pic30_debug)
            printf("  setting SEC_DATA for section %s\n",
                   os->bfd_section->name);
        }
      else
        {
          /* anything else is marked SEC_CODE */
          os->bfd_section->flags |= SEC_CODE;
          if (pic30_debug)
            printf("  setting SEC_CODE for section %s\n",
                    os->bfd_section->name);
        }
    }
}


/*
** before_allocation()
**
** This function is called after input sections
** have been mapped to output sections.
**
*/
static void  
gld${EMULATION_NAME}_before_allocation()
{
  if (pic30_debug)
    {
      printf("\nBefore allocation:\n");
      bfd_pic30_print_section_header();
      bfd_map_over_sections(output_bfd, &bfd_pic30_report_sections, 0);
      printf("\nPre-calculating output sections\n");
    }

  {
    lang_memory_region_type *region = region_lookup("program");

    /* adjust the program region location counters, for CodeGuard */
    if (region->current != base_address[GENERALx][FLASHx]) {
      if (pic30_debug)
        printf("\nChanging the current location of region 'program' to 0x%lx\n",
               base_address[GENERALx][FLASHx]);
      region->current = base_address[GENERALx][FLASHx];
    }
  }

} /*static void gld${EMULATION_NAME}_before_allocation ()*/


/*
** after_allocation()
**
** This function is called after section offsets
** have been determined and output section sizes
** are known.
**
** At this point, symbols declared in the linker
** script and on the command line are visible
** in the global hash table.
**
** Process __NO_HANDLES if present.
**
** Update flags for sections that are created
** exclusively in the linker script.
*/
static void  
gld${EMULATION_NAME}_after_allocation()
{
  asection *sec;

  {
    struct bfd_link_hash_entry *h;

    /*
    ** If __DATA_BASE is defined, capture its value
    ** for use in object compatibility testing.
    */
    if ((!data_base_defined) &&
        (h = bfd_pic30_is_defined_global_symbol("__DATA_BASE")))
      {
        data_base = h->u.def.value;
        data_base_defined = TRUE;
      }
      else
        {}; /* __DATA_BASE is optional for now.. */

    /* If we need a dma address range, make sure
    ** it is defined.
    */
    if (need_dma_memory)
      confirm_dma_range_defined();

    /*
    ** Look for a symbol called __NO_HANDLES
    ** and test its value. If TRUE, remove the
    ** handle jump table.
    **
    ** This is a secondary method to suppress handles.
    ** The primary method is the --no-handles option.
    */
    if ((h = bfd_pic30_is_defined_global_symbol("__NO_HANDLES")))
      {
        if ((h->u.def.value) && handle_bfd)
          {
            sec = bfd_get_section_by_name(handle_bfd, ".handle");
            if (sec && (sec->_raw_size > 0))
              {
                sec->_raw_size = 0;
                bfd_set_section_size (handle_bfd, sec, 0);
                handles = 0; /* remove the hash table also...
                                bfd/coff-pic30.c tests this at reloc time
                                (note: BFD releases the memory) */
                if (pic30_debug)
                  printf("\nStripping section \".handle\"\n");
              }
          }
      }
  }

  {
    lang_statement_union_type *u;
    lang_output_section_statement_type *lookup;
    bfd_boolean found_user_init = FALSE;

    /*
    ** Scan through the output section statements
    ** and check the section flags.
    **
    ** An output section created exclusively by
    ** the linker script (i.e, no input sections)
    ** will not have the correct flags set.
    **
    ** Update the flags so that every section can be
    ** classified as data memory or program memory.
    ** This info is needed for the memory usage report.
    **
    ** Also look for section .user_init. If defined
    ** in a sequential output section, save the
    ** output_offset for later.
    */

    if (pic30_debug)
      printf("\nChecking section flags:\n");

    for (u = lang_output_section_statement.head;
         u != (lang_statement_union_type *) NULL;
         u = lookup->next) {
         
      lookup = &u->output_section_statement;
      pic30_set_output_section_flags(lookup);
        
      if ((user_init_bfd == 0) ||
          (lookup->bfd_section == 0) || found_user_init) continue;

      if (lookup->bfd_section == user_init_bfd->sections->output_section) {
        lang_statement_union_type *s;

        for (s = lookup->children.head;
             s != (lang_statement_union_type *) NULL;
             s = s->header.next) {
               
          if (found_user_init) break;
          if ((s->header.type == lang_input_section_enum) &&
              (strcmp(s->input_section.section->name, ".user_init") == 0)) {
            user_init_offset = s->input_section.section->output_offset;
            found_user_init = TRUE;
            if (pic30_debug)
              printf("\nFound user_init at %lx\n",
                     lookup->bfd_section->lma + user_init_offset);
          }

          if (s->header.type == lang_wild_statement_enum) {
            lang_statement_union_type *ss;
            for (ss = s->wild_statement.children.head;
                 ss != (lang_statement_union_type *) NULL;
                 ss = ss->header.next) {
              if ((ss->header.type == lang_input_section_enum) &&
                  (strcmp(ss->input_section.section->name, ".user_init") == 0)) {
                user_init_offset = ss->input_section.section->output_offset;
                found_user_init = TRUE;
                if (pic30_debug)
                  printf("\nFound wild user_init at %lx\n",
                         lookup->bfd_section->lma + user_init_offset);
                break;
              }
            }
          }
        }
      }
    }
  }

  if (pic30_debug)
    {
      printf("\nAfter sequential allocation:\n");
      bfd_pic30_print_section_header();
      bfd_map_over_sections(output_bfd, &bfd_pic30_report_sections, 0);

      printf("\nMemory Regions\n");
      bfd_pic30_print_region_info("data");
      bfd_pic30_print_region_info("program");
    }

  /* 
  ** Invoke the best-fit allocator
  */
  if (pic30_allocate) {
    allocate_memory();

    if (pic30_debug)
      {
        printf("\nAfter best-fit allocation:\n");
        bfd_pic30_print_section_header();
        bfd_map_over_sections(output_bfd, &bfd_pic30_report_sections, 0);

        printf("\nMemory Regions\n");
        bfd_pic30_print_region_info("data");
        bfd_pic30_print_region_info("program");
      }
#if 0
    {
      lang_statement_union_type *s;
      for (s = statement_list.head;
           s != (lang_statement_union_type *) NULL;
           s = s->header.next)
        if (s->header.type == lang_output_section_statement_enum)
          print_output_section_statement((lang_output_section_statement_type *)s);
    }
#endif
  }
} /* static void gld${EMULATION_NAME}_after_allocation ()*/


/*
** finish()
**
** This function is called after symbol assignments
** are completed, but before relocations are resolved.
*/
static void  
gld${EMULATION_NAME}_finish()
{
  if (pic30_debug)
    {
      printf("\nBefore finish:\n");
      bfd_pic30_print_section_header();
      bfd_map_over_sections(output_bfd, &bfd_pic30_report_sections, 0);
    }
  bfd_pic30_finish();
  if (pic30_debug)
    {
      printf("\nAfter finish:\n");
      bfd_pic30_print_section_header();
      bfd_map_over_sections(output_bfd, &bfd_pic30_report_sections, 0);

      printf("\nMemory Regions\n");
      bfd_pic30_print_region_info("data");
      bfd_pic30_print_region_info("program");

      printf("\nDynamic Memory\n");
      printf("  heap:  %x bytes, %x to %x\n",
             (heap_limit - heap_base + 2), heap_base, heap_limit);
      printf("  stack: %x bytes, %x to %x\n",
             (stack_limit - stack_base + 2), stack_base, stack_limit);
    } /* if (pic30_debug */

  if (config.map_file != NULL) {
    char *p = pic30_unique_selected_configword_names();

    if (strlen(p) > 0) {
      fprintf(config.map_file,"\n");
      pic30_dump_selected_codeguard_options(config.map_file);
      dump_codeguard_flash_boundaries(config.map_file);
      dump_codeguard_ram_boundaries(config.map_file);
      if (pic30_is_eedata_machine(global_PROCESSOR))
        dump_codeguard_eeprom_boundaries(config.map_file);
    }
    else if (pic30_has_user_boot || pic30_has_user_secure) {
      fprintf(config.map_file,"\n");
      dump_user_defined_codeguard_segments(config.map_file);
      dump_codeguard_flash_boundaries(config.map_file);
      dump_codeguard_ram_boundaries(config.map_file);
    }

    bfd_pic30_report_memory_usage (config.map_file);
    pic30_report_external_symbols (config.map_file);
  }
  if (pic30_report_mem)
    bfd_pic30_report_memory_usage (stdout);
} /* static void gld${EMULATION_NAME}_finish ()*/


/*
** region_lookup()
**
** Call this instead of lang_memory_region_lookup()
** if you want reasonable defaults set for the
** following regions:
**
** data
** program
** psv
** eedata
**
** Note: Ideally, every linker script will include
** these definitions. But we don't want to fail
** if the user is running with a minimal script.
*/
#define NAME_IS(s) \
  ((strlen(name) == strlen(#s)) && \
           strcmp(name, (#s)) == 0)

static lang_memory_region_type *
region_lookup( name )
     char * name;
{
  lang_memory_region_type *region;
  bfd_vma upper_limit = 0;
  int use_default = 0;

  region = lang_memory_region_lookup (name);
  if (region->length == ~(bfd_size_type) 0) {
    if (NAME_IS(data)) {
      use_default = 1;
      region->origin = 0x800;     /* works with simulator */
      upper_limit    = 0xFFFE;
    }
    else if (NAME_IS(program)) {
      use_default = 1;
      region->origin = 0x100;     /* works with simulator */
      upper_limit    = 0x3FFFE;
    }
    else if (NAME_IS(eedata)) {
      use_default = 1;
      region->origin = 0x7FFC00;  /* works with all devices */
      upper_limit    = 0x7FFFFE;
    }
    else
      einfo("Memory region %s does not exist\n", name);

    if (use_default) {
      einfo(_("%P: Warning: %s memory region not defined,"
              " using default range: 0x%v .. 0x%v\n"),
            name, region->origin, upper_limit);
      region->current = region->origin;
      region->length = upper_limit - region->origin + 2;
    }
  }
  return region;
}


/*
** place_orphan()
**
** This emulation function is called after
** all explicitly mapped input sections have
** been assigned to their output sections.
**
** Any "orphan" or un-mapped sections should
** be placed here; otherwise the linker will
** assign them to memory regions based on
** region attributes.
*/
static int
gld${EMULATION_NAME}_place_orphan( file, sec)
  lang_input_statement_type *file;
  asection *sec;
{
  lang_output_section_statement_type *os = 0;
  static int orphan_cnt = 0;
  int was_placed = 0;

  /* if section has PSV attribute, record that fact */
  if (PIC30_IS_PSV_ATTR(sec) && (sec->_raw_size > 0))
    has_psv_section = TRUE;

  if (pic30_allocate) {  /* if best-fit allocator enabled */

    /* if this section represents a memory region,
       we don't want it allocated or its relocations
       processed. */
    if (PIC30_IS_INFO_ATTR(sec) &&
        strncmp(sec->name, memory_region_prefix,
                strlen(memory_region_prefix)) == 0) {
                
      if (!memory_region_list)
        pic30_init_section_list(&memory_region_list);

      if (!pic30_name_in_section_list(memory_region_list, sec->name))
        pic30_append_section_to_list(memory_region_list, file, sec);
      has_user_defined_memory = TRUE;
      return 1;
    }

    if (((sec->flags & SEC_DEBUGGING) == SEC_DEBUGGING)
        || ((sec->flags & SEC_ALLOC) == 0))
      return 0; /* let the base code handle non-alloc sections */

    /* no need to set implied attributes here, because elf
       object files never pre-date v1.30 (see pic30_coff.em) */

#if 0
    /* allow the sequential allocator to combine
       all input sections named .const */
    if (strcmp(sec->name, ".const") == 0)
      return 0;
#endif

    /* record it for later processing */
    if (pic30_debug)
      printf("%sRecording unmapped section: \"%s\", attr = %x\n",
             orphan_cnt++ ? "" : "\n", sec->name,
             pic30_attribute_map(sec));

    if (!unassigned_sections)
      pic30_init_section_list(&unassigned_sections);

    pic30_append_section_to_list(unassigned_sections, file, sec);

    return 1;  /* and exit */
  }

  /* if we get here, best-fit allocator is disabled */
  if (sec->psv)
    {
      /* create an output section (statement) */
      os = lang_output_section_statement_lookup (sec->name);

      os->region = region_lookup ("data");
      os->lma_region = region_lookup ("program");

      lang_add_section (&os->children, sec, os, file);
      was_placed = 1;
    }
  else if (sec->eedata)
    {
      /* create an output section (statement) */
      os = lang_output_section_statement_lookup (sec->name);

      os->region = region_lookup ("eedata");

      lang_add_section (&os->children, sec, os, file);
      was_placed = 1;
    }

  return was_placed;

} /*static void gld${EMULATION_NAME}_place_orphan () */


static bfd_boolean
elf_link_check_archive_element (name, abfd, info)
     char *name;
     bfd *abfd;
     struct bfd_link_info *info;
{
  bfd_boolean result = TRUE;
  unsigned int signature_pairs = 0;
  unsigned int signature_mask = 0;
  unsigned int signature_set = 0;
  bfd_boolean has_sig = bfd_has_signature(abfd,
                                          &signature_pairs,
                                          &signature_mask,
                                          &signature_set);

  if ((global_PROCESSOR) &&
      (bfd_default_compatible(abfd->arch_info, global_PROCESSOR) == 0))
    return FALSE;

  if (strcmp(name, CRT0_KEY) == 0) {
    if (pic30_data_init == 0) {
      _bfd_generic_link_add_one_symbol (info, pic30_output_bfd, CRT0_KEY,
                                        BSF_GLOBAL, bfd_abs_section_ptr,
                                        0, CRT0_KEY, 1, 0, 0);
      if (pic30_debug)
        printf("\nData init is disabled, so %s defined as NULL\n", CRT0_KEY);
      return FALSE;
    } else if (pic30_startup0_file &&
               (strcmp(abfd->filename, pic30_startup0_file) != 0)) {
      if (pic30_debug)
        printf("\n%s defines %s, but does not match CRT0 startup module\n",
               abfd->filename, CRT0_KEY);
      return FALSE;
    }
  }

  if (strcmp(name, CRT1_KEY) == 0) {
    if (pic30_data_init) {
      _bfd_generic_link_add_one_symbol (info, pic30_output_bfd, CRT1_KEY,
                                        BSF_GLOBAL, bfd_abs_section_ptr,
                                        0, CRT1_KEY, 1, 0, 0);
      if (pic30_debug)
        printf("\nData init is enabled, so %s defined as NULL\n", CRT1_KEY);
      return FALSE;
    } else if (pic30_startup1_file &&
               (strcmp(abfd->filename, pic30_startup1_file) != 0)) {
      if (pic30_debug)
        printf("\n%s defines %s, but does not match CRT1 startup module\n",
               abfd->filename, CRT1_KEY);
      return FALSE;
    }
  }
 
  /*
  ** Compare object signatures
  */
  if (pic30_select_objects) {
    const char *dbg_str1 = "\nSeeking a definition for %s (0x%x 0x%x)\n";
    const char *dbg_str2 = "  consider %s (0x%x 0x%x) ... ";
    const char *dbg_str3 = "no signature found\n";
    struct pic30_undefsym_entry *usym = 0;
    unsigned int mask;

    /* Except for trivial cases, the undefined symbols table
       should already exist. */

    /* Load the entry for this symbol.
       If no entry exists, the symbol must have been declared
       in a linker script. Take no action here. */
    if (undefsyms)
      usym = pic30_undefsym_lookup(undefsyms, name, 0, 0);

    if (pic30_debug && usym) {
      printf(dbg_str1, name, usym->external_options_mask,
             usym->options_set);
      printf(dbg_str2, abfd->filename, signature_mask, signature_set);
    }

    /* If the archive object has no signature,
       and the referencing object(s) has external options that are set,
       Then this object is not compatible */
    if (usym && (has_sig == FALSE) && (usym->external_options_mask &
                                       usym->options_set)) {
      if (pic30_debug)
        printf(dbg_str3);
      result = FALSE;
    }

    /* If the archive object has a signature,
       compare it to the undefined symbol entry */
    if (usym && has_sig) {
      mask = signature_mask | usym->external_options_mask;
      if ((mask & signature_set) == (mask & usym->options_set)) {
        if (pic30_debug)
          printf("OK\n");
        result = TRUE;
      } else {
        result = FALSE;
        if (pic30_debug)
          printf(" not compatible\n");
      }
    }
  }
  if (result == FALSE) return FALSE;

#if (defined(C30_SMARTIO_RULES) && (C30_SMARTIO_RULES > 1))
  /* we may need to pull this symbol in because it is a SMARTIO fn */
  if (pic30_force_keep_symbol)
      (void) pic30_force_keep_symbol(name, abfd->filename);
#endif
  return TRUE;
} 

/*
 *  This file is awkard.
 */ 

static bfd_boolean
bfd_has_signature(bfd *abfd, unsigned int *pairs,
                  unsigned int *mask, unsigned int *set) {
  asection *sec;
  unsigned char *dat;
  bfd_boolean result = FALSE;

    for (sec = abfd->sections; sec != NULL; sec = sec->next) {
      if(PIC30_IS_INFO_ATTR(sec) &&
         (strcmp(sec->name, "__c30_signature") == 0)) {

        /* load the section contents */
        if (sec->flags & SEC_IN_MEMORY)
          dat = sec->contents;
        else {
          const char *err_str = "Link Error: can't load section %s contents\n";
          dat = malloc(sec->_raw_size);
          bfd_seek(sec->owner, 0, SEEK_SET); /* avoid Windows bug */
          if (!bfd_get_section_contents(sec->owner, sec, dat,
                                        0, sec->_raw_size)) {
            fprintf(stderr, err_str, sec->name);
            abort();
          }
        }

        /* read the signature from this library object
           (skip phantom bytes) */
        *pairs =  dat[0] | (dat[2] << 8);
        *mask  =  dat[4] | (dat[6] << 8);
        *set   =  dat[8] | (dat[10] << 8);

        if (dat != sec->contents)
          free(dat);
        result = TRUE;
        break;
      }
    }
    return result;
}

static void
update_object_compatibility(const char *symname, bfd *abfd,
                                  unsigned int *signature_mask,
                                  unsigned int *signature_set) {
  const char *err_str = "Link Error: reference to \'%s\' in \'%s\'"
                        " is not compatible with previous references\n";
  struct pic30_undefsym_entry *usym;
  unsigned int mask;

  if (pic30_debug)
    printf("  undefined: %s\n", symname);

  if (!undefsyms)  /* create the table, if necessary */
    undefsyms = pic30_undefsym_init();

  /* create or load a table entry for this symbol */
  usym = pic30_undefsym_lookup(undefsyms, symname, 1, 0);

  if (usym->most_recent_reference == 0) {
    usym->most_recent_reference = abfd;
    usym->external_options_mask = signature_mask[0];
    usym->options_set = signature_set[0];
  } else {
    /* compare this reference to previous reference(s) */
    if (pic30_debug) {
      printf("    previous reference:  %s\n",
             usym->most_recent_reference->filename);
      printf("    composite signature: %x %x\n",
             usym->external_options_mask, usym->options_set);
    }
    mask = signature_mask[0] & usym->external_options_mask;
    if ((mask & signature_set[0]) == (mask & usym->options_set)) {
      /* references are compatible, update table entry */
      usym->most_recent_reference = abfd;
      usym->external_options_mask |= signature_mask[0];
      usym->options_set |= signature_set[0];
      if (pic30_debug)
        printf("    updated signature:   %x %x\n",
               usym->external_options_mask, usym->options_set);
    } else {
      /* report an error */
      fprintf(stderr, err_str, symname, abfd->filename);
      abort();
    }
  }
}


bfd_boolean (*pic30_elf_link_check_archive_element)(char *name, bfd *abfd,
                                                    struct bfd_link_info *) = 
  elf_link_check_archive_element;

void (*pic30_update_object_compatibility)(const char *symname, bfd *abfd,
                                    unsigned int *signature_mask,
                                    unsigned int *signature_set) = 
  update_object_compatibility;

bfd_boolean (*pic30_bfd_has_signature)(bfd *abfd, unsigned int *pairs,
                                       unsigned int *mask, 
                                       unsigned int *set) =
  bfd_has_signature;
#include "../bfd/pic30-options.c"

/*
** get_script()
**
** This function returns the default linker script.
**
** It gets filled in by a shell script during
** the build process, when epic30_coff.c is
** created in the binary directory.
*/
static char *
gld${EMULATION_NAME}_get_script(isfile)
     int *isfile;

EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{			     
  *isfile = 0;

  if (link_info.relocateable == TRUE && config.build_constructors == TRUE)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == TRUE) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

cat >>e${EMULATION_NAME}.c <<EOF
{			     
  *isfile = 1;

  if (link_info.relocateable == TRUE && config.build_constructors == TRUE)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocateable == TRUE)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF

fi

cat >>e${EMULATION_NAME}.c <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
{
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  gld${EMULATION_NAME}_after_parse,
  gld${EMULATION_NAME}_after_open,
  gld${EMULATION_NAME}_after_allocation,
  gld${EMULATION_NAME}_set_output_arch,
  ldemul_default_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  gld${EMULATION_NAME}_finish,
  NULL,	/* create output section statements */
  NULL,	/* open dynamic archive */
  gld${EMULATION_NAME}_place_orphan,
  NULL,	/* set symbols */
  pic30_parse_args,	/* parse args */
  NULL, /* add options */
  NULL, /* handle option */
  NULL,	/* unrecognized file */
  pic30_list_options,	/* list options */
  NULL,	/* recognized file */
  NULL,	/* find_potential_libraries */
  NULL 	/* new_vers_pattern */
};
EOF
